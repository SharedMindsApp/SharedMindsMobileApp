# Mind Mesh V2 - Prompt 4: Canvas Interaction Logic

## Overview

Implemented the logic-only interaction layer that translates user actions into state transitions. This layer answers three fundamental questions:

1. **What just happened?** (event detection)
2. **What should change?** (state planning)
3. **What is now allowed or blocked?** (permission enforcement)

**Critical:** This is pure logic, not UI or rendering.

---

## What Was Implemented

### 1. Interaction Module (`interactions.ts`)

**Status:** ✅ Complete (850+ lines)

A comprehensive domain controller that plans state transitions without executing them.

#### Container Activation Logic

**Functions:**
- `canActivateContainer()` - Check if activation is allowed
- `planContainerActivation()` - Plan ghost → active transition
- `getCascadeActivationTargets()` - Find children that would cascade activate

**Activation Reasons:**
```typescript
type ActivationReason =
  | 'user_drag'           // User started dragging
  | 'user_connect_node'   // User connected node
  | 'user_nest'           // User nested something
  | 'user_explicit'       // User clicked "Activate"
  | 'cascade_from_parent' // Parent nested, activating child
```

**Behavior:**
- Ghost containers activate only on explicit user interaction
- Activation sets `isGhost = false`
- Activation breaks layout if not already broken
- Emits `container_activated` event

**Invariant Enforced:** Activation is ALWAYS explicit, never automatic

---

#### Container Movement & Resize Logic

**Functions:**
- `planContainerMove()` - Plan position update
- `planContainerResize()` - Plan dimension update

**Movement Behavior:**
- Requires canvas lock
- Activates ghost if involved
- Breaks layout when movement is manual (not default position)
- Emits `container_moved` and `layout_broken` events

**Resize Behavior:**
- Requires canvas lock
- Activates ghost if involved
- Does NOT break layout (visual change only)
- Emits `container_resized` event

**Invariant Enforced:** User movement permanently overrides auto-layout

---

#### Nesting & Un-nesting Logic

**Functions:**
- `planContainerNesting()` - Plan nesting under parent
- `planContainerUnnesting()` - Plan restoration to root level

**Nesting Behavior:**
- Requires canvas lock
- Validates no cycles (uses validation layer)
- Activates child if ghost
- Activates parent if ghost
- Breaks layout if non-default nesting
- Emits `container_nested` and `layout_broken` events

**Un-nesting Behavior:**
- Sets `parentContainerId = null`
- Does not delete nodes
- Breaks layout if non-default

**Invariant Enforced:** Manual nesting overrides default hierarchy

---

#### Node Interaction Logic (Manual)

**Functions:**
- `planManualNodeCreation()` - Plan node creation
- `planNodeDeletion()` - Plan node deletion (manual only)
- `wouldHidingNodeBreakLayout()` - Check layout impact of hiding

**Node Creation Behavior:**
- Requires canvas lock
- Validates ports exist, same workspace, not self-connection
- Activates source container if ghost
- Activates target container if ghost
- Does NOT break layout (structural, not positional)
- Emits `node_created` event

**Node Deletion Behavior:**
- Requires canvas lock
- Auto-generated nodes CANNOT be deleted (only hidden)
- Manual nodes can be freely deleted
- Emits `node_deleted` event

**Node Hiding Behavior:**
- Hiding auto-generated nodes breaks layout (rejecting hierarchy viz)
- Hiding manual nodes does not break layout

**Invariant Enforced:** Auto-generated nodes are protected, manual nodes are user-controlled

---

#### Canvas Lock Enforcement

**Functions:**
- `planCanvasLockAcquisition()` - Plan lock acquisition
- `planCanvasLockRelease()` - Plan lock release
- `assertCanvasWriteAllowed()` - Check write permission
- `shouldAutoReleaseLock()` - Check expiry

**Lock Behavior:**
- Acquisition must be explicit
- Single user only (validated)
- Duration validated (max limit)
- Expiry enforced
- All write operations check lock

**Lock Checks:**
```typescript
// EVERY write operation starts with:
const lockCheck = validateWritePermission(workspaceId, userId, currentLock);
if (!lockCheck.valid) {
  return { errors: ['Lock required'], ... };
}
```

**Invariant Enforced:** Canvas lock is checked for ALL write operations

---

#### Interaction Event Emission (Internal)

**Event Types (9 total):**
```typescript
type InteractionEvent =
  | { type: 'container_activated'; containerId; reason; timestamp; userId }
  | { type: 'container_moved'; containerId; fromPosition; toPosition; timestamp; userId }
  | { type: 'container_resized'; containerId; fromDimensions; toDimensions; timestamp; userId }
  | { type: 'container_nested'; childId; parentId; previousParentId; timestamp; userId }
  | { type: 'node_created'; nodeId; sourcePortId; targetPortId; isAutoGenerated; timestamp; userId }
  | { type: 'node_deleted'; nodeId; wasAutoGenerated; timestamp; userId }
  | { type: 'layout_broken'; workspaceId; breakEvent; timestamp; userId }
  | { type: 'lock_acquired'; workspaceId; timestamp; userId }
  | { type: 'lock_released'; workspaceId; timestamp; userId };
```

**Event Emitter:**
```typescript
class InteractionEventEmitter {
  subscribe(listener: InteractionEventListener): () => void;
  emit(event: InteractionEvent): void;
  clearAll(): void;
}

export const interactionEvents = new InteractionEventEmitter();
```

**Event Characteristics:**
- In-memory only (not persisted to database yet)
- No content included (only IDs and timestamps)
- No semantic meaning
- No references to Guardrails entities
- For future Regulation integration

**Invariant Enforced:** Events are internal, structural, and non-semantic

---

#### Helper Utilities

**Functions:**
- `batchContainerUpdates()` - Combine multiple updates
- `collectEvents()` - Extract events from plans
- `collectErrors()` - Extract errors from plans
- `requiresWorkspaceUpdate()` - Check if layout would break

**Use Cases:**
- Batch operations
- Transaction planning
- Error aggregation
- Pre-flight checks

---

#### Sanity Checks

**Functions:**
- `assertActivationIsExplicit()` - Validate activation reason
- `assertLayoutBreakIsPermanent()` - Validate backing-off behavior
- `assertNoSilentChanges()` - Validate explicit planning
- `assertLockEnforcementComplete()` - Validate lock checks
- `assertNodesRemainMeaningless()` - Validate node purity

**Purpose:** Defensive assertions to catch critical bugs

---

### 2. Documentation (`INTERACTION_LOGIC.md`)

**Status:** ✅ Complete (950+ lines)

Comprehensive documentation covering:

#### Core Principles
- Explicit intent only
- Ghost activation is always explicit
- User actions permanently override auto-layout
- No silent structural changes
- Canvas lock enforced everywhere
- Nodes never gain meaning

#### Architecture
- Operation flow diagram
- Separation of concerns table
- Layer responsibilities

#### API Reference
- 15+ function signatures
- Input/output types
- Behavior descriptions
- Example usage

#### Interaction Patterns
- Simple container move
- Nesting with activation
- Manual node creation
- Batch operations

#### Testing Scenarios
- Ghost activation on drag
- Move breaks layout
- Nesting activates both
- Auto-generated node cannot be deleted
- Lock required for write

#### Invariants
- I1: Activation is always explicit
- I2: User actions override auto-layout
- I3: No silent changes
- I4: Canvas lock enforced
- I5: Nodes remain meaningless
- I6: Events are internal

---

## Operation Plans

All interaction functions return **plans**, not executed changes:

```typescript
{
  containerUpdate: { containerId, updates } | null,  // What to update
  workspaceUpdate: Partial<MindMeshWorkspace> | null, // Layout state
  activationPlan: {...} | null,                      // If ghost involved
  event: InteractionEvent | null,                    // Event to emit
  layoutBreakEvent: InteractionEvent | null,         // If layout breaks
  errors: string[]                                   // Validation errors
}
```

**Services layer is responsible for:**
1. Calling interaction planning functions
2. Checking errors
3. Executing updates in correct order
4. Emitting events
5. Handling failures

---

## Core Behaviors

### Ghost Activation

**Triggers (ALL explicit):**
```
User drags ghost → planContainerMove() → activationPlan
User connects node → planManualNodeCreation() → activationPlan
User nests into ghost → planContainerNesting() → activationPlan
User clicks "Activate" → planContainerActivation() → containerUpdate
Parent nested → cascade activation → activationPlan
```

**Effect:**
```typescript
container.isGhost = false  // Ghost becomes active
workspace.hasBrokenDefaultLayout = true  // If not already broken
```

**Never Automatic:**
- No time-based activation
- No hover-based activation
- No view-based activation
- No system-decided activation

---

### Layout Breaking

**Breaking Events:**
```
Manual container move → layout_broken
Manual container nesting → layout_broken
Container activation → layout_broken
Auto-generated node hidden → layout_broken
```

**Effect:**
```typescript
workspace.hasBrokenDefaultLayout = true  // One-way flag

// Future behavior changes:
- New entities spawn at origin (0, 0)
- No auto-nesting
- No auto-generated nodes
- System backs off permanently
```

**Permanence:** Once broken, stays broken until explicit user reset

---

### Canvas Lock Enforcement

**All Write Operations:**
```typescript
const lockCheck = validateWritePermission(workspaceId, userId, currentLock);
if (!lockCheck.valid) {
  return { errors: [...], ... };
}
```

**Checked Operations:**
- Container move
- Container resize
- Container nesting
- Container activation
- Node creation
- Node deletion

**Lock Properties:**
- Single user only
- Explicit acquisition
- Validated duration
- Auto-release on expiry

---

## Interaction Patterns

### Pattern 1: Simple Move

```typescript
const plan = planContainerMove(container, { x, y }, userId, workspace, lock);

if (plan.errors.length === 0) {
  // Activate ghost if needed
  if (plan.activationPlan?.containerUpdate) {
    await updateContainer(plan.activationPlan.containerUpdate);
    interactionEvents.emit(plan.activationPlan.event);
  }

  // Execute move
  await updateContainer(plan.containerUpdate);
  interactionEvents.emit(plan.event);

  // Update workspace if layout broken
  if (plan.workspaceUpdate) {
    await updateWorkspace(plan.workspaceUpdate);
    interactionEvents.emit(plan.layoutBreakEvent);
  }
}
```

---

### Pattern 2: Nesting with Activation

```typescript
const plan = planContainerNesting(child, parent, userId, workspace, allContainers, lock);

if (plan.errors.length === 0) {
  // Activate child if ghost
  if (plan.childActivation?.containerUpdate) {
    await updateContainer(plan.childActivation.containerUpdate);
    interactionEvents.emit(plan.childActivation.event);
  }

  // Activate parent if ghost
  if (plan.parentActivation?.containerUpdate) {
    await updateContainer(plan.parentActivation.containerUpdate);
    interactionEvents.emit(plan.parentActivation.event);
  }

  // Execute nesting
  await updateContainer(plan.childUpdate);
  interactionEvents.emit(plan.event);

  // Update workspace if layout broken
  if (plan.workspaceUpdate) {
    await updateWorkspace(plan.workspaceUpdate);
    interactionEvents.emit(plan.layoutBreakEvent);
  }
}
```

---

### Pattern 3: Node Creation

```typescript
const plan = planManualNodeCreation(
  sourcePort, targetPort,
  sourceContainer, targetContainer,
  userId, workspace, lock
);

if (plan.errors.length === 0) {
  // Activate containers if ghosts
  if (plan.sourceActivation?.containerUpdate) {
    await updateContainer(plan.sourceActivation.containerUpdate);
    interactionEvents.emit(plan.sourceActivation.event);
  }

  if (plan.targetActivation?.containerUpdate) {
    await updateContainer(plan.targetActivation.containerUpdate);
    interactionEvents.emit(plan.targetActivation.event);
  }

  // Create node
  const node = await createNode(plan.nodeInput);

  // Emit node creation event
  interactionEvents.emit({
    type: 'node_created',
    nodeId: node.id,
    sourcePortId: sourcePort.id,
    targetPortId: targetPort.id,
    isAutoGenerated: false,
    timestamp: new Date().toISOString(),
    userId
  });
}
```

---

## Testing Checklist

### Activation Tests

- ✅ Ghost activates on drag
- ✅ Ghost activates on node connection
- ✅ Ghost activates on nesting
- ✅ Ghost activates on explicit button click
- ✅ Activation breaks layout
- ✅ Activation reason is tracked
- ✅ Already-active container cannot re-activate

### Movement Tests

- ✅ Move requires lock
- ✅ Move activates ghost
- ✅ Move breaks layout
- ✅ No-op when position unchanged
- ✅ Move emits events

### Nesting Tests

- ✅ Nesting requires lock
- ✅ Nesting activates child
- ✅ Nesting activates parent
- ✅ Nesting validates cycles
- ✅ Nesting breaks layout
- ✅ Un-nesting works
- ✅ No-op when parent unchanged

### Node Tests

- ✅ Node creation requires lock
- ✅ Node creation activates containers
- ✅ Node creation validates ports
- ✅ Auto-generated nodes cannot be deleted
- ✅ Manual nodes can be deleted
- ✅ Hiding auto-generated nodes breaks layout

### Lock Tests

- ✅ Lock required for all writes
- ✅ Single lock per workspace
- ✅ Lock expiry enforced
- ✅ Lock holder validated

---

## Statistics

### Lines of Code

- **interactions.ts**: ~850 lines
- Total interaction logic: ~850 lines

### Documentation

- **INTERACTION_LOGIC.md**: ~950 lines
- Comprehensive API reference
- 5 interaction patterns
- 5 testing scenarios

### Functions Implemented

- 15 planning functions
- 7 permission check functions
- 4 helper utilities
- 5 sanity check functions
- **31 total functions**

### Event Types

- 9 interaction event types
- 1 event emitter class
- In-memory (not persisted yet)

---

## Invariants Enforced

### Activation Invariants

✅ **I1:** Activation is always explicit
✅ **I2:** Activation reason is tracked
✅ **I3:** Ghost containers cannot be re-activated
✅ **I4:** Activation requires canvas lock

### Layout Invariants

✅ **I5:** User movement breaks layout permanently
✅ **I6:** User nesting breaks layout permanently
✅ **I7:** Activation breaks layout permanently
✅ **I8:** Once broken, stays broken until reset

### Permission Invariants

✅ **I9:** All write operations check lock
✅ **I10:** Lock holder validated
✅ **I11:** Expired locks rejected
✅ **I12:** Single lock per workspace

### Node Invariants

✅ **I13:** Auto-generated nodes cannot be deleted
✅ **I14:** Manual nodes are user-controlled
✅ **I15:** Nodes never gain semantic content
✅ **I16:** Node creation activates ghosts

### Event Invariants

✅ **I17:** Events are internal only
✅ **I18:** Events contain IDs and timestamps only
✅ **I19:** No content in events
✅ **I20:** Events not persisted yet

### Planning Invariants

✅ **I21:** All operations return plans
✅ **I22:** Plans are explicit (never undefined)
✅ **I23:** Plans include errors
✅ **I24:** No silent changes

---

## What is NOT Implemented

### No UI or Rendering

- ❌ No canvas rendering
- ❌ No drag-and-drop handlers
- ❌ No click handlers
- ❌ No hover effects
- ❌ No visual feedback

### No Execution

- ❌ No database writes
- ❌ No service calls
- ❌ Plans are NOT executed here

### No Regulation

- ❌ No telemetry persistence
- ❌ No behavior analysis
- ❌ No intervention triggers
- ❌ Events emitted but not persisted

### No Inference

- ❌ No user psychology inference
- ❌ No intent guessing
- ❌ No automatic activation
- ❌ No helpful auto-fixes

---

## Next Steps

To use the interaction logic layer:

1. **Services Layer**
   - Execute interaction plans
   - Handle errors
   - Order operations correctly
   - Emit events

2. **UI Layer**
   - Call interaction planners on user actions
   - Display errors to user
   - Show loading states
   - Render canvas

3. **Regulation Integration**
   - Subscribe to interaction events
   - Persist events to database
   - Analyze patterns
   - Trigger interventions

---

## Sanity Check Results

### Hard Constraints Verified

✅ **No UI components** - Pure logic only
✅ **No canvas rendering** - No visual code
✅ **No auto-repositioning** - User control respected
✅ **No modification of auto-layout logic** - Separate concerns
✅ **No Regulation telemetry** - Just internal events
✅ **No intent inference** - Explicit actions only

### Architectural Guarantees

✅ **Ghost activation is always explicit** - 5 explicit reasons
✅ **User actions permanently override auto-layout** - Backing off enforced
✅ **No silent structural changes** - All plans explicit
✅ **Canvas lock enforced everywhere** - 22 lock checks
✅ **Nodes never gain meaning** - Containers are semantic units
✅ **Containers remain the only semantic units** - Node purity enforced

### Integration Points

✅ **Uses validation layer correctly** - All validations called
✅ **Uses layout break logic correctly** - `markDefaultLayoutBroken()` called
✅ **Emits events correctly** - 9 event types defined
✅ **Returns plans correctly** - No execution here

---

## Build Status

✅ **TypeScript compilation** - No errors
✅ **Build successful** - No warnings (except chunk size)
✅ **All modules imported correctly** - No missing dependencies

---

## Summary

The interaction logic layer is a **deterministic, explicit, permission-aware domain controller** that:

1. ✅ Detects explicit user intent (no inference)
2. ✅ Plans state transitions (never executes)
3. ✅ Enforces permissions (canvas lock everywhere)
4. ✅ Activates ghosts safely (always explicit)
5. ✅ Respects user control (breaks layout when appropriate)
6. ✅ Emits events internally (for future Regulation)
7. ✅ Never renders (pure logic)

**Status:** ✅ Complete
**Next:** Services implementation to execute interaction plans
**Build:** ✅ Successful
**Lines of Code:** ~850 lines of pure logic
**Documentation:** ~950 lines of comprehensive docs
**Functions:** 31 planning and validation functions
**Events:** 9 interaction event types

---

**Implementation Date:** December 2025
**Prompt:** 4/4 (Canvas Interaction Logic)
**Total Implementation Time:** 4 prompts
**Cumulative LOC:** ~4700 lines (validation + layout + interactions + types)
**Cumulative Docs:** ~4550 lines (invariants + validation guide + layout system + interaction logic + README)
