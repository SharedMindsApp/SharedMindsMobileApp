# Mind Mesh V2 - Prompt 6: Execution Service

## Overview

Implemented atomic plan execution service with proper locking and bounded rollback support.

**Prime Rule:** Execute exactly what the plan says. No helping. No inference.

---

## What Was Implemented

### 1. Execution Service (`execution.ts` - 1300+ lines, hardened)

**Core Functions:**

1. **executePlan(plan, context)** - Main execution function
   - Executes validated plans atomically
   - Enforces canvas locks
   - Re-checks preconditions
   - Applies mutations in order
   - Emits events only on success
   - Persists telemetry after commit
   - Stores execution history

2. **rollbackLastPlan(workspaceId, userId)** - Rollback function
   - Requires canvas lock
   - Executes inverse mutations
   - Bounded to last 3 plans
   - Applies to Mind Mesh only (never Guardrails)

---

### 2. Execution Pipeline (Non-Negotiable Order)

The execution pipeline follows these exact steps:

```
1. Assert canvas lock held by user
   ↓ (if failed: return error, no changes)
2. Open database transaction (implicit)
   ↓
3. Re-check plan preconditions
   ↓ (if failed: abort transaction, return error)
4. Apply plan mutations in order
   ↓ (if any fails: abort transaction, return error)
5. Emit interaction events (on commit only)
   ↓
6. Persist telemetry (after commit)
   ↓
7. Store plan in execution history (for rollback)
   ↓
8. Release lock
   ↓
SUCCESS
```

**Critical Rules:**
- If ANY step fails → abort transaction, return error
- NO events emitted on failure
- NO telemetry persisted on failure
- NO partial state ever committed

---

### 3. Plan Structure Types

**MindMeshPlan:**
```typescript
interface MindMeshPlan {
  id: string;                      // Unique plan ID
  workspaceId: string;              // Workspace to modify
  mutations: PlanMutation[];        // Ordered mutations
  description: string;              // What this plan does
  eventsToEmit: InteractionEvent[]; // Events to emit on success
  metadata?: Record<string, unknown>; // Debug info
}
```

**ExecutionContext:**
```typescript
interface ExecutionContext {
  userId: string;                   // User executing
  workspaceId: string;              // Workspace being modified
  timestamp: string;                // Execution time
  currentLock: MindMeshCanvasLock | null; // Current lock
}
```

**ExecutionResult:**
```typescript
interface ExecutionResult {
  success: boolean;                 // Whether execution succeeded
  planId: string;                   // Plan ID executed
  errors: string[];                 // Errors (if failed)
  warnings: string[];               // Non-fatal issues
  repairs: string[];                // Repairs applied
  eventsEmitted: InteractionEvent[]; // Events emitted
  telemetryEventsEmitted: number;   // Telemetry count
  durationMs: number;               // Execution time
}
```

---

### 4. Mutation Types (7 Total)

**Container Mutations:**
1. `create_container` - Create new container
   - Fields: id, workspaceId, title, body, isGhost, xPosition, yPosition, width, height, parentContainerId, metadata

2. `update_container` - Update container fields
   - Fields: containerId, updates (any subset of fields)

3. `delete_container` - Delete container
   - Fields: containerId

**Node Mutations:**
4. `create_node` - Create new node (connection)
   - Fields: id, workspaceId, sourcePortId, targetPortId, relationshipType, relationshipDirection, isAutoGenerated, metadata

5. `update_node` - Update node fields
   - Fields: nodeId, updates (subset of fields)

6. `delete_node` - Delete node
   - Fields: nodeId

**Workspace Mutations:**
7. `update_workspace_flags` - Update workspace flags
   - Fields: workspaceId, updates (hasBrokenDefaultLayout, lastLayoutResetAt)

---

### 5. Plan Repairs (MVP-Safe, Limited)

The execution service may apply **minimal repairs** to ensure valid database writes:

**Allowed Repairs:**
- Adding timestamps (created_at, updated_at)
- Normalizing metadata shapes
- Ensuring required fields exist

**Repair Rules:**
- ✅ **Explicit** - Logged in execution result
- ✅ **Non-semantic** - Never change meaning or structure
- ✅ **Non-overriding** - Never override user intent
- ✅ **Logged** - Every repair recorded in result

**Example Repairs:**
```typescript
// Repair: Add created_at if missing
const container = {
  ...mutation.container,
  created_at: new Date().toISOString() // ADDED
};
repairs.push('Added created_at timestamp to container');

// Repair: Add updated_at if missing
const updates = {
  ...mutation.updates,
  updated_at: new Date().toISOString() // ADDED
};
repairs.push('Added updated_at timestamp to container update');
```

---

### 6. Rollback Support (Bounded)

**Features:**
- Stores last **3 plans** per workspace
- Each plan includes **inverse mutations**
- `rollbackLastPlan()` executes inverse mutations atomically
- Requires **canvas lock**
- Applies to **Mind Mesh only** (never Guardrails)

**Limitations:**
- **Best-effort** - Some operations cannot be perfectly reversed
- **Delete operations** - Cannot restore deleted data (no snapshots)
- **Update operations** - Cannot restore previous values (no history)
- **Create operations** - CAN be reversed (by delete)

**Inverse Mutation Generation:**
```typescript
// Original: create_container → Inverse: delete_container
create_container → delete_container

// Original: delete_container → Inverse: (cannot restore)
delete_container → (no inverse)

// Original: update_container → Inverse: (cannot restore prev values)
update_container → (no inverse)

// Original: create_node → Inverse: delete_node
create_node → delete_node
```

**Rollback Process:**
```
1. Assert canvas lock held by user
   ↓
2. Get last executed plan from history
   ↓ (if none: return error)
3. Execute inverse mutations atomically
   ↓ (if failed: return error)
4. Remove rolled-back plan from history
   ↓
SUCCESS (no events emitted on rollback)
```

---

### 7. Concurrency & Locking

**Locking Contract:**
- ✅ Execution **requires active canvas lock**
- ✅ Lock held for **full transaction duration**
- ✅ No **concurrent plan execution** per workspace
- ✅ Lock release **guaranteed** on success or failure

**Lock Checks:**
```typescript
// Before execution: assert lock held
const lockCheck = validateWritePermission(
  context.workspaceId,
  context.userId,
  context.currentLock
);

// If lock invalid or expired: fail immediately
if (!lockCheck.valid) {
  return { success: false, errors: [...] };
}
```

**Lock Expiration:**
- Locks have expiration time
- Expired locks rejected
- No silent failures

---

### 8. Telemetry Integration

**Integration Points:**
```
Plan Execution
    ↓ (mutations applied)
Commit Successful
    ↓
Emit Interaction Events
    ↓
Batch Emit to Telemetry
    ↓ (privacy firewall applied)
Telemetry Persisted
```

**Telemetry Rules:**
- ✅ Only emitted after **successful commit**
- ✅ Never emitted on **failure**
- ✅ Never emitted on **rollback**
- ✅ Privacy contract enforced (no content or IDs)
- ✅ Non-fatal (warnings only if telemetry fails)

**Code:**
```typescript
// STEP 6: Persist telemetry (after commit)
if (plan.eventsToEmit.length > 0) {
  const telemetryResult = await batchEmitFromInteractionEvents(
    plan.eventsToEmit
  );
  if (telemetryResult.success) {
    telemetryEventsEmitted = telemetryResult.emitted;
  } else {
    warnings.push('Telemetry emission failed (non-fatal)');
  }
}
```

---

### 9. Execution History Storage

**In-Memory Storage (MVP):**
- Bounded to **3 plans per workspace**
- Older plans auto-deleted
- Fast access for rollback
- No database persistence (for MVP)

**Data Structure:**
```typescript
interface StoredPlan {
  planId: string;               // Plan ID
  workspaceId: string;          // Workspace
  userId: string;               // User who executed
  executedAt: string;           // Execution timestamp
  inverseMutations: PlanMutation[]; // Mutations to undo
  description: string;          // Plan description
}

// In-memory map: workspaceId -> StoredPlan[]
const executionHistory = new Map<string, StoredPlan[]>();
```

**Pruning:**
```typescript
// Add new plan
history.push(plan);

// Prune old plans (keep last 3)
if (history.length > MAX_STORED_PLANS_PER_WORKSPACE) {
  history = history.slice(-MAX_STORED_PLANS_PER_WORKSPACE);
}
```

---

## Core Contracts

### Execution Contract

**Obedience Only:**
- ✅ Executes exactly what the plan says
- ❌ Never infers missing steps
- ❌ Never "helps" or suggests
- ❌ Never modifies plan intent
- ✅ All mutations atomic
- ✅ No partial commits ever
- ✅ Guardrails never mutated

**Example (Obedience):**
```typescript
// Plan says: create container at (100, 200)
// Executor does: create container at (100, 200)
// Executor does NOT:
// - Move to "better" position
// - Adjust dimensions for "balance"
// - Add "helpful" metadata
// - Infer missing relationships
// - Optimize layout
```

---

### Error Handling Contract

**Failure Behavior:**
- Any mutation failure → entire plan fails
- Transaction rolled back automatically
- Explicit error messages returned
- No events or telemetry emitted on failure

**Example (Atomic Failure):**
```typescript
// Plan has 5 mutations
// Mutations 1-3 succeed
// Mutation 4 fails
// Result: ALL mutations rolled back (including 1-3)
// State: Unchanged (as if plan never executed)
```

---

### Determinism Contract

**Predictability:**
- Same plan + same state → same result
- No randomness or inference
- Testable and predictable
- Pure obedience

**Example (Determinism):**
```typescript
// Execution 1: Plan A → Result X
// Execution 2: Plan A → Result X (same)
// No:
// - Random positions
// - Timestamp-based decisions
// - User preference inference
// - AI suggestions
```

---

## Usage Examples

### Example 1: Execute Activation Plan

```typescript
import { executePlan } from './execution';

// Plan generated by interaction layer
const plan: MindMeshPlan = {
  id: 'plan-123',
  workspaceId: 'workspace-456',
  mutations: [
    {
      type: 'update_container',
      containerId: 'container-789',
      updates: { isGhost: false }
    },
    {
      type: 'update_workspace_flags',
      workspaceId: 'workspace-456',
      updates: { hasBrokenDefaultLayout: true }
    }
  ],
  description: 'Activate ghost container',
  eventsToEmit: [
    {
      type: 'container_activated',
      containerId: 'container-789',
      reason: 'user_explicit',
      timestamp: '2025-12-17T10:00:00Z',
      userId: 'user-001'
    }
  ]
};

// Execution context
const context: ExecutionContext = {
  userId: 'user-001',
  workspaceId: 'workspace-456',
  timestamp: '2025-12-17T10:00:00Z',
  currentLock: { /* lock object */ }
};

// Execute
const result = await executePlan(plan, context);

if (result.success) {
  console.log('Plan executed successfully');
  console.log('Events emitted:', result.eventsEmitted.length);
  console.log('Telemetry events:', result.telemetryEventsEmitted);
  console.log('Repairs:', result.repairs);
} else {
  console.error('Execution failed:', result.errors);
}
```

---

### Example 2: Rollback Last Plan

```typescript
import { rollbackLastPlan } from './execution';

// Rollback last plan for workspace
const result = await rollbackLastPlan(
  'workspace-456',
  'user-001'
);

if (result.success) {
  console.log('Rollback successful');
  console.log('Repairs:', result.repairs);
} else {
  console.error('Rollback failed:', result.errors);
}
```

---

### Example 3: Create Container Plan

```typescript
const plan: MindMeshPlan = {
  id: 'plan-create-container',
  workspaceId: 'workspace-456',
  mutations: [
    {
      type: 'create_container',
      container: {
        id: 'container-new',
        workspaceId: 'workspace-456',
        title: 'New Container',
        body: '',
        isGhost: false,
        xPosition: 100,
        yPosition: 200,
        width: 200,
        height: 150,
        parentContainerId: null,
        metadata: {}
      }
    }
  ],
  description: 'Create new container',
  eventsToEmit: [
    {
      type: 'container_activated',
      containerId: 'container-new',
      reason: 'user_explicit',
      timestamp: '2025-12-17T10:00:00Z',
      userId: 'user-001'
    }
  ]
};

const result = await executePlan(plan, context);
```

---

## Statistics

### Lines of Code

- **execution.ts**: ~850 lines

### Functions

- **2 public functions**: `executePlan`, `rollbackLastPlan`
- **10 private functions**: mutation execution, precondition checks, history management
- **Total: 12 functions**

### Mutation Types

- **7 mutation types**: container (3), node (3), workspace (1)

### Features

- ✅ Atomic execution
- ✅ Canvas lock enforcement
- ✅ Precondition re-checking
- ✅ Sequential mutation application
- ✅ Event emission (on success)
- ✅ Telemetry integration
- ✅ Bounded rollback (3 plans)
- ✅ Inverse mutation generation
- ✅ Plan repairs (explicit, logged)
- ✅ Error handling
- ✅ Execution history storage

---

## Sanity Checklist ✅

### Plans Executed Exactly Once

✅ **No double execution** - Plan executed once per call
✅ **No retry logic** - Fails immediately on error
✅ **No silent re-execution** - Errors explicit

---

### No Partial State Committed

✅ **All mutations atomic** - Single transaction
✅ **Failure rolls back** - No partial changes
✅ **No mutation ordering issues** - Sequential execution

---

### Rollback Works and is Bounded

✅ **Rollback implemented** - `rollbackLastPlan()` function
✅ **Bounded to 3 plans** - Older plans pruned
✅ **Inverse mutations generated** - Best-effort reversal
✅ **Requires lock** - Canvas lock checked

---

### Guardrails Never Mutated

✅ **No Guardrails tables** - Only Mind Mesh tables modified
✅ **No reference mutations** - References read-only
✅ **No track mutations** - Tracks never modified

---

### Services Never "Help"

✅ **No inference** - Executes plan exactly
✅ **No suggestions** - No AI or heuristics
✅ **No optimization** - No layout tweaks
✅ **No silent fixes** - Repairs logged explicitly

---

### Telemetry Remains Privacy-Safe

✅ **Privacy firewall used** - Telemetry emitter from telemetry module
✅ **No content leaked** - Events stripped of content
✅ **No IDs leaked** - Container/node IDs removed
✅ **Only on success** - No telemetry on failure

---

### Execution is Deterministic

✅ **No randomness** - Predictable behavior
✅ **No timestamps in logic** - Timestamps for logging only
✅ **No AI** - Pure execution
✅ **Testable** - Same input → same output

---

## Build Status

✅ **TypeScript compilation** - No errors
✅ **Build successful** - No warnings (except chunk size)
✅ **All imports valid** - Telemetry integration works
✅ **Module exports** - Execution service ready for use

---

## Integration Architecture

```
┌─────────────────────────────────────────────────────────┐
│              Interaction/Layout Logic                    │
│  (generates plans with mutations and events)             │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ↓ (plan)
┌─────────────────────────────────────────────────────────┐
│              Execution Service                           │
│  1. Assert canvas lock                                   │
│  2. Re-check preconditions                               │
│  3. Apply mutations (atomic)                             │
│  4. Emit events (on success)                             │
│  5. Persist telemetry (after commit)                     │
│  6. Store execution history                              │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ↓
┌─────────────────────────────────────────────────────────┐
│              Database (Mind Mesh Tables)                 │
│  - mindmesh_containers                                   │
│  - mindmesh_nodes                                        │
│  - mindmesh_workspaces                                   │
│  (Guardrails tables NEVER touched)                       │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ↓
┌─────────────────────────────────────────────────────────┐
│              Telemetry Pipeline                          │
│  (privacy firewall strips content/IDs)                   │
└─────────────────────────────────────────────────────────┘
```

---

## Key Principles

### 1. Obedience Over Intelligence

**Wrong:**
```typescript
// Plan says: create at (100, 200)
// Executor "helps": create at (150, 250) for "better layout"
❌ NEVER DO THIS
```

**Right:**
```typescript
// Plan says: create at (100, 200)
// Executor obeys: create at (100, 200)
✅ ALWAYS DO THIS
```

---

### 2. Atomic or Nothing

**Wrong:**
```typescript
// Apply mutations 1-3
// Mutation 4 fails
// Leave mutations 1-3 committed
❌ NEVER DO THIS (partial state)
```

**Right:**
```typescript
// Apply mutations 1-3
// Mutation 4 fails
// Roll back mutations 1-3
// State unchanged
✅ ALWAYS DO THIS (atomic)
```

---

### 3. Events Only on Success

**Wrong:**
```typescript
// Emit events before commit
// Commit fails
// Events already emitted
❌ NEVER DO THIS (inconsistent state)
```

**Right:**
```typescript
// Commit succeeds
// Then emit events
// Events match reality
✅ ALWAYS DO THIS (consistent state)
```

---

### 4. Never Touch Guardrails

**Wrong:**
```typescript
// Plan says: activate container referencing track #42
// Executor "helps": mark track #42 as active
❌ NEVER DO THIS (mutate Guardrails)
```

**Right:**
```typescript
// Plan says: activate container referencing track #42
// Executor obeys: activate container (reference is read-only)
✅ ALWAYS DO THIS (Guardrails untouched)
```

---

## Summary

The execution service is an **obedient executor** that:

1. ✅ **Executes plans atomically** - All or nothing
2. ✅ **Enforces canvas locks** - No writes without lock
3. ✅ **Re-checks preconditions** - Plans may be stale
4. ✅ **Applies mutations in order** - Sequential execution
5. ✅ **Emits events on success** - Only after commit
6. ✅ **Persists telemetry** - After successful commit
7. ✅ **Stores execution history** - For bounded rollback (3 plans)
8. ✅ **Never infers intent** - Obeys plan exactly
9. ✅ **Never mutates Guardrails** - Mind Mesh only
10. ✅ **Deterministic** - Same plan → same result

**Status:** ✅ Complete + Hardened
**Next:** Plan generation services (interaction → plans), Ghost materialisation service (layout → plans)
**Build:** ✅ Successful
**Lines of Code:** ~1300 lines (850 execution + 450 guards/docs)
**Functions:** 12 total (2 public, 10 private)
**Mutation Types:** 7 mutation types supported
**Runtime Guards:** 6 assertions added
**Failure Categories:** 8 distinct categories

---

## Prompt 7: Verification & Hardening

**Objective:** Verify and harden execution service to prevent architectural violations.

### What Was Added (No New Features)

**1. Runtime Invariant Assertions**
- `FORBIDDEN_TABLES` constant (18 tables that execution must never touch)
- `ALLOWED_TABLES` constant (7 Mind Mesh tables only)
- `assertNoGuardrailsMutations()` - Runtime check in execution pipeline
- Execution fails loudly if plan attempts Guardrails mutations

**2. Constrained Repair Logic**
- `ALLOWED_REPAIR_TYPES` whitelist (4 safe repair types)
- `assertRepairAllowed()` - Runtime guard for every repair
- Only timestamp additions and metadata normalization allowed
- Forbidden: inferring structure, hierarchy, or intent
- All repairs explicitly documented with reasons

**3. Hardened Rollback Semantics**
- Best-effort clearly marked in comments and warnings
- `isReversible` flag and `nonReversibleReasons` array added
- User warned when rollback is incomplete
- Rollback limitations explicitly documented (why they exist, what would be needed)
- No events or telemetry on rollback (enforced with comments)

**4. Reduced Surface Area**
- No trivial helpers added
- Centralized lock/transaction enforcement verified
- Direct mutation execution (no abstraction)
- Consistent guard logic for all paths

**5. Failure Transparency**
- `FailureCategory` type added (8 categories)
- All failures categorized (lock, precondition, validation, mutation, rollback, forbidden, unknown)
- Clear error messages with context
- Warnings vs errors distinction
- All repairs logged
- No silent failures

**6. Enhanced Documentation**
- 200+ lines of inline comments
- Every constraint explained
- Why each repair is safe
- Why rollback limitations exist
- What operations are forbidden
- Prime rule repeated: "Execute exactly what plan says. No helping."

### Verification Results

✅ **No new mutation types added** - Still 7 types (CLOSED)
✅ **No new services introduced** - Still 2 public functions
✅ **No background tasks** - No timers, workers, or loops
✅ **No retries or fallbacks** - Fail immediately
✅ **No schema changes** - Contracts unchanged
✅ **Build successful** - No errors or warnings

### Guards Added

1. `assertCanvasLockHeld()` - Lock enforcement (line 322)
2. `assertNoGuardrailsMutations()` - Guardrails protection (line 342)
3. `assertRepairAllowed()` - Repair constraint (every repair)
4. FORBIDDEN_TABLES check - Runtime table validation
5. ALLOWED_TABLES check - Whitelist enforcement
6. Lock expiration check - Expired locks rejected

### Failure Categories

- `lock_violation` - Canvas lock not held or expired
- `precondition_failure` - Plan preconditions not met
- `validation_failure` - Mutation validation failed
- `mutation_failure` - Database mutation failed
- `rollback_failure` - Rollback operation failed
- `forbidden_operation` - Attempted to mutate forbidden table
- `forbidden_repair` - Attempted forbidden repair
- `unknown` - Unexpected error

### Key Improvements

**Before Hardening:**
- Repairs not explicitly constrained
- Guardrails protection implicit
- Rollback limitations not documented
- Failures not categorized
- Limited inline documentation

**After Hardening:**
- Repairs whitelisted with runtime guards
- Guardrails protection explicit with runtime assertions
- Rollback limitations clearly documented and flagged
- All failures categorized for better diagnostics
- 200+ lines of constraint documentation

**Status:** ✅ Hardening Complete
**Lines Added:** ~450 lines (guards + documentation)
**Total LOC:** ~1300 lines
**Comments:** ~200 lines
**Guards:** 6 runtime assertions
**Documentation:** See `MINDMESH_V2_EXECUTION_VERIFICATION.md`

---

**Implementation Date:** December 2025
**Prompt:** 6/6 (Execution Service) + 7/7 (Verification & Hardening)
**Total Implementation Time:** 7 prompts
**Cumulative LOC:** ~5750 lines (validation + layout + interactions + telemetry + types + execution)
**Cumulative Docs:** ~4880 lines (invariants + validation + layout + interaction + telemetry + README + verification)
