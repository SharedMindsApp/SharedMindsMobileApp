/**
 * Mind Mesh V2 Plan Generation Service
 *
 * Converts high-level intents and Guardrails events into executable plans.
 *
 * CRITICAL RULES:
 * - Plans are generated, never executed
 * - All logic delegated to existing planners
 * - No mutations, no database writes
 * - No canvas locking, no telemetry
 * - No UI code, no retries, no inference
 * - Layout state respected at plan time
 * - Guardrails authority preserved
 *
 * This layer ONLY plans. Execution service handles execution.
 *
 * Why planning is separate from execution:
 * - Plans can be validated before execution
 * - Plans can be queued, batched, or deferred
 * - Plans can be rolled back
 * - Plans are testable without side effects
 * - Clear separation of concerns
 */

import type {
  MindMeshWorkspace,
  MindMeshContainer,
  MindMeshNode,
  MindMeshCanvasLock,
  MindMeshPort,
} from './types';

import type {
  PlanMutation,
  MindMeshPlan,
} from './execution';

import {
  planContainerActivation,
  planContainerMove,
  planContainerResize,
  planContainerNesting,
  planContainerUnnesting,
  planManualContainerCreation,
  planManualNodeCreation,
  planNodeDeletion,
  type ActivationReason,
  type InteractionEvent,
} from './interactions';

import {
  planGhostMaterialisation,
  planAutoGeneratedHierarchyNodes,
  planResetToDefaultLayout,
} from './layout';

import {
  validateIntegratedTrackCreation,
  validateIntegratedSubtrackCreation,
  validateIntegratedTaskCreation,
  validateIntegratedEventCreation,
  type ValidationResult,
} from './guardrailsValidation';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Context required for plan generation.
 * Provides current state without mutating it.
 */
export interface PlanContext {
  userId: string;
  workspaceId: string;
  timestamp: string;
  workspace: MindMeshWorkspace;
  currentLock: MindMeshCanvasLock | null;

  // Current state snapshots (read-only)
  containers: MindMeshContainer[];
  nodes: MindMeshNode[];
  ports: MindMeshPort[];
}

/**
 * User intents that can be converted into plans.
 *
 * CRITICAL: This list is CLOSED. No new intent types may be added without architectural review.
 * Each intent maps to an existing planner function.
 */
export type MindMeshIntent =
  | {
      type: 'MoveContainer';
      containerId: string;
      newPosition: { x: number; y: number };
    }
  | {
      type: 'ResizeContainer';
      containerId: string;
      newDimensions: { width: number; height: number };
    }
  | {
      type: 'NestContainer';
      childId: string;
      parentId: string;
    }
  | {
      type: 'UnnestContainer';
      childId: string;
    }
  | {
      type: 'ActivateGhostContainer';
      containerId: string;
      reason: ActivationReason;
    }
  | {
      type: 'CreateManualContainer';
      containerType: 'idea' | 'note';
      position: { x: number; y: number };
      title?: string;
      body?: string;
      width?: number;
      height?: number;
    }
  | {
      type: 'CreateIntegratedTrack';
      position: { x: number; y: number };
      name: string;
      description?: string;
      color?: string;
      width?: number;
      height?: number;
    }
  | {
      type: 'CreateIntegratedSubtrack';
      parentTrackId: string;
      position: { x: number; y: number };
      name: string;
      description?: string;
      width?: number;
      height?: number;
    }
  | {
      type: 'PromoteContainerToTrack';
      containerId: string;
      trackName?: string;
      trackDescription?: string;
      trackColor?: string;
    }
  | {
      type: 'PromoteContainerToSubtrack';
      containerId: string;
      parentTrackId: string;
      subtrackName?: string;
      subtrackDescription?: string;
    }
  | {
      type: 'CreateIntegratedTask';
      position: { x: number; y: number };
      parentTrackId: string;
      title: string;
      description?: string;
      dueAt?: string;
      width?: number;
      height?: number;
    }
  | {
      type: 'CreateIntegratedEvent';
      position: { x: number; y: number };
      parentTrackId: string;
      title: string;
      description?: string;
      startsAt: string;
      endsAt?: string;
      width?: number;
      height?: number;
    }
  | {
      type: 'PromoteContainerToTask';
      containerId: string;
      parentTrackId: string;
      taskTitle?: string;
      taskDescription?: string;
      dueAt?: string;
    }
  | {
      type: 'PromoteContainerToEvent';
      containerId: string;
      parentTrackId: string;
      eventTitle?: string;
      eventDescription?: string;
      startsAt: string;
      endsAt?: string;
    }
  | {
      type: 'CreateManualNode';
      sourcePortId: string;
      targetPortId: string;
      relationshipType: string;
      relationshipDirection: string;
    }
  | {
      type: 'DeleteNode';
      nodeId: string;
      isManual: boolean;
    }
  | {
      type: 'ResetLayout';
      force: boolean;
    };

/**
 * Plan generation result.
 * Either a valid plan or explicit errors.
 */
export interface PlanResult {
  success: boolean;
  plan: MindMeshPlan | null;
  errors: string[];
  warnings: string[];
}

// ============================================================================
// PLAN GENERATION SERVICE
// ============================================================================

/**
 * Generates a plan from a user intent.
 *
 * PRIME RULE: Delegate to existing planners. Never implement new logic.
 *
 * Process:
 * 1. Validate intent is supported
 * 2. Fetch required entities from context
 * 3. Call existing planner function
 * 4. Convert planner output to PlanMutation[]
 * 5. Wrap in MindMeshPlan
 * 6. Return plan (never execute)
 *
 * Why layout state is consulted here:
 * - Planning must respect workspace.hasBrokenDefaultLayout
 * - If layout is intact: use default hierarchy planners
 * - If layout is broken: spawn containers free-floating
 * - This decision is made at plan-time, not execution-time
 * - Ensures plans match current layout mode
 *
 * @param intent - High-level user intent
 * @param context - Current workspace state (read-only)
 * @returns Plan ready for execution or errors
 */
export async function planFromIntent(
  intent: MindMeshIntent,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  try {
    switch (intent.type) {
      case 'MoveContainer':
        return planMoveContainerIntent(intent, context);

      case 'ResizeContainer':
        return planResizeContainerIntent(intent, context);

      case 'NestContainer':
        return planNestContainerIntent(intent, context);

      case 'UnnestContainer':
        return planUnnestContainerIntent(intent, context);

      case 'ActivateGhostContainer':
        return planActivateGhostIntent(intent, context);

      case 'CreateManualContainer':
        return planCreateManualContainerIntent(intent, context);

      case 'CreateIntegratedTrack':
        return planCreateIntegratedTrackIntent(intent, context);

      case 'CreateIntegratedSubtrack':
        return planCreateIntegratedSubtrackIntent(intent, context);

      case 'PromoteContainerToTrack':
        return planPromoteContainerToTrackIntent(intent, context);

      case 'PromoteContainerToSubtrack':
        return planPromoteContainerToSubtrackIntent(intent, context);

      case 'CreateIntegratedTask':
        return planCreateIntegratedTaskIntent(intent, context);

      case 'CreateIntegratedEvent':
        return planCreateIntegratedEventIntent(intent, context);

      case 'PromoteContainerToTask':
        return planPromoteContainerToTaskIntent(intent, context);

      case 'PromoteContainerToEvent':
        return planPromoteContainerToEventIntent(intent, context);

      case 'CreateManualNode':
        return planCreateManualNodeIntent(intent, context);

      case 'DeleteNode':
        return planDeleteNodeIntent(intent, context);

      case 'ResetLayout':
        return planResetLayoutIntent(intent, context);

      default:
        errors.push(`Unknown intent type: ${(intent as any).type}`);
        return { success: false, plan: null, errors, warnings };
    }
  } catch (error) {
    errors.push(`Plan generation failed: ${error}`);
    return { success: false, plan: null, errors, warnings };
  }
}

// ============================================================================
// INTENT HANDLERS (DELEGATION ONLY)
// ============================================================================

/**
 * Plans a container move intent.
 * Delegates to planContainerMove from interactions.
 */
function planMoveContainerIntent(
  intent: Extract<MindMeshIntent, { type: 'MoveContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planContainerMove(
    container,
    intent.newPosition,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.containerUpdate) {
    mutations.push({
      type: 'update_container',
      containerId: planResult.containerUpdate.containerId,
      updates: planResult.containerUpdate.updates,
    });
  }

  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Move container ${intent.containerId} to (${intent.newPosition.x}, ${intent.newPosition.y})`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a container resize intent.
 * Delegates to planContainerResize from interactions.
 */
function planResizeContainerIntent(
  intent: Extract<MindMeshIntent, { type: 'ResizeContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planContainerResize(
    container,
    intent.newDimensions,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.containerUpdate) {
    mutations.push({
      type: 'update_container',
      containerId: planResult.containerUpdate.containerId,
      updates: planResult.containerUpdate.updates,
    });
  }

  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Resize container ${intent.containerId} to ${intent.newDimensions.width}x${intent.newDimensions.height}`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a container nesting intent.
 * Delegates to planContainerNesting from interactions.
 */
function planNestContainerIntent(
  intent: Extract<MindMeshIntent, { type: 'NestContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find containers
  const child = context.containers.find((c) => c.id === intent.childId);
  const parent = context.containers.find((c) => c.id === intent.parentId);

  if (!child) {
    errors.push(`Child container not found: ${intent.childId}`);
    return { success: false, plan: null, errors, warnings };
  }

  if (!parent) {
    errors.push(`Parent container not found: ${intent.parentId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planContainerNesting(
    child,
    parent,
    context.userId,
    context.workspace,
    context.currentLock,
    context.containers
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.childUpdate) {
    mutations.push({
      type: 'update_container',
      containerId: planResult.childUpdate.containerId,
      updates: planResult.childUpdate.updates,
    });
  }

  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Nest container ${intent.childId} into ${intent.parentId}`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a container unnesting intent.
 * Delegates to planContainerUnnesting from interactions.
 */
function planUnnestContainerIntent(
  intent: Extract<MindMeshIntent, { type: 'UnnestContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find container
  const child = context.containers.find((c) => c.id === intent.childId);
  if (!child) {
    errors.push(`Container not found: ${intent.childId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planContainerUnnesting(
    child,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.childUpdate) {
    mutations.push({
      type: 'update_container',
      containerId: planResult.childUpdate.containerId,
      updates: planResult.childUpdate.updates,
    });
  }

  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Unnest container ${intent.childId}`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a ghost activation intent.
 * Delegates to planContainerActivation from interactions.
 */
function planActivateGhostIntent(
  intent: Extract<MindMeshIntent, { type: 'ActivateGhostContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  if (!container.isGhost) {
    warnings.push(`Container ${intent.containerId} is not a ghost, skipping activation`);
    return { success: true, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planContainerActivation(
    container,
    intent.reason,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.containerUpdate) {
    mutations.push({
      type: 'update_container',
      containerId: planResult.containerUpdate.containerId,
      updates: planResult.containerUpdate.updates,
    });
  }

  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Activate ghost container ${intent.containerId} (reason: ${intent.reason})`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a manual container creation intent.
 * Delegates to planManualContainerCreation from interactions.
 */
function planCreateManualContainerIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateManualContainer' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Delegate to existing planner
  const planResult = planManualContainerCreation(
    intent.containerType,
    intent.position,
    intent.title,
    intent.body,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.containerInput) {
    // Generate unique container ID
    const containerId = `container-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

    // Match existing create_container mutation structure
    mutations.push({
      type: 'create_container',
      container: {
        id: containerId,
        workspaceId: planResult.containerInput.workspaceId,
        title: planResult.containerInput.title || '',
        body: planResult.containerInput.body || '',
        isGhost: false,
        xPosition: planResult.containerInput.xPosition,
        yPosition: planResult.containerInput.yPosition,
        width: planResult.containerInput.width,
        height: planResult.containerInput.height,
        parentContainerId: null,
        metadata: planResult.containerInput.metadata,
      },
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create manual ${intent.containerType} at (${intent.position.x}, ${intent.position.y})`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a manual node creation intent.
 * Delegates to planManualNodeCreation from interactions.
 */
function planCreateManualNodeIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateManualNode' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find ports
  const sourcePort = context.ports.find((p) => p.id === intent.sourcePortId);
  const targetPort = context.ports.find((p) => p.id === intent.targetPortId);

  if (!sourcePort) {
    errors.push(`Source port not found: ${intent.sourcePortId}`);
    return { success: false, plan: null, errors, warnings };
  }

  if (!targetPort) {
    errors.push(`Target port not found: ${intent.targetPortId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planManualNodeCreation(
    sourcePort,
    targetPort,
    intent.relationshipType,
    intent.relationshipDirection,
    context.userId,
    context.workspace,
    context.currentLock,
    context.nodes
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.node) {
    mutations.push({
      type: 'create_node',
      node: planResult.node,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create manual node from ${intent.sourcePortId} to ${intent.targetPortId}`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a node deletion intent.
 * Delegates to planNodeDeletion from interactions.
 */
function planDeleteNodeIntent(
  intent: Extract<MindMeshIntent, { type: 'DeleteNode' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Find node
  const node = context.nodes.find((n) => n.id === intent.nodeId);
  if (!node) {
    errors.push(`Node not found: ${intent.nodeId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planNodeDeletion(
    node,
    intent.isManual,
    context.userId,
    context.workspace,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  if (planResult.nodeId) {
    mutations.push({
      type: 'delete_node',
      nodeId: planResult.nodeId,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Delete ${intent.isManual ? 'manual' : 'auto-generated'} node ${intent.nodeId}`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a layout reset intent.
 * Delegates to planResetToDefaultLayout from layout.
 *
 * CRITICAL: This respects workspace.hasBrokenDefaultLayout.
 * If layout is already intact and force=false, no-op.
 */
function planResetLayoutIntent(
  intent: Extract<MindMeshIntent, { type: 'ResetLayout' }>,
  context: PlanContext
): PlanResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check if reset is needed
  if (!context.workspace.hasBrokenDefaultLayout && !intent.force) {
    warnings.push('Layout is already intact, skipping reset');
    return { success: true, plan: null, errors, warnings };
  }

  // Delegate to existing planner
  const planResult = planResetToDefaultLayout(
    context.workspace,
    context.containers,
    context.nodes,
    context.userId,
    context.currentLock
  );

  if (planResult.errors.length > 0) {
    errors.push(...planResult.errors);
    return { success: false, plan: null, errors, warnings };
  }

  // Convert to mutations
  const mutations: PlanMutation[] = [];
  const events: InteractionEvent[] = [];

  // Container updates
  for (const update of planResult.containerUpdates) {
    mutations.push({
      type: 'update_container',
      containerId: update.containerId,
      updates: update.updates,
    });
  }

  // Workspace update
  if (planResult.workspaceUpdate) {
    mutations.push({
      type: 'update_workspace_flags',
      workspaceId: context.workspaceId,
      updates: planResult.workspaceUpdate,
    });
  }

  if (planResult.event) {
    events.push(planResult.event);
  }

  // Wrap in plan
  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Reset layout to default hierarchy (force=${intent.force})`,
    eventsToEmit: events,
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans an integrated track creation intent.
 * Validates against Guardrails constraints, then generates plan for both
 * Guardrails entity creation and Mind Mesh container creation.
 */
async function planCreateIntegratedTrackIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateIntegratedTrack' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validate against Guardrails constraints BEFORE planning
  const validation = await validateIntegratedTrackCreation({
    masterProjectId: context.workspace.masterProjectId,
    name: intent.name,
    description: intent.description,
    color: intent.color,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Require canvas lock for integrated creation
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to create integrated track');
    return { success: false, plan: null, errors, warnings };
  }

  // Generate unique IDs
  const trackId = `track-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  const containerId = `container-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  // Create plan with both Guardrails and Mind Mesh mutations
  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails track (executed first)
  mutations.push({
    type: 'create_guardrails_track',
    track: {
      id: trackId,
      masterProjectId: context.workspace.masterProjectId,
      parentTrackId: null,
      name: intent.name,
      description: intent.description || null,
      color: intent.color || null,
      orderingIndex: 0, // Will be auto-calculated by Guardrails
    },
  });

  // 2. Create Mind Mesh container (executed second, references track)
  mutations.push({
    type: 'create_integrated_container',
    container: {
      id: containerId,
      workspaceId: context.workspaceId,
      title: intent.name,
      body: intent.description || null,
      isGhost: false,
      xPosition: intent.position.x,
      yPosition: intent.position.y,
      width: intent.width || 300,
      height: intent.height || 200,
      parentContainerId: null,
      metadata: {
        source: 'mind_mesh_creation',
        createdAt: context.timestamp,
      },
    },
    entityType: 'track',
    entityId: trackId,
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create integrated track "${intent.name}" at (${intent.position.x}, ${intent.position.y})`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans an integrated subtrack creation intent.
 * Validates against Guardrails constraints, then generates plan for both
 * Guardrails entity creation and Mind Mesh container creation.
 */
async function planCreateIntegratedSubtrackIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateIntegratedSubtrack' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validate against Guardrails constraints BEFORE planning
  const validation = await validateIntegratedSubtrackCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    name: intent.name,
    description: intent.description,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Require canvas lock for integrated creation
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to create integrated subtrack');
    return { success: false, plan: null, errors, warnings };
  }

  // Generate unique IDs
  const subtrackId = `track-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  const containerId = `container-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  // Create plan with both Guardrails and Mind Mesh mutations
  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails subtrack (executed first)
  mutations.push({
    type: 'create_guardrails_track',
    track: {
      id: subtrackId,
      masterProjectId: context.workspace.masterProjectId,
      parentTrackId: intent.parentTrackId,
      name: intent.name,
      description: intent.description || null,
      color: null,
      orderingIndex: 0, // Will be auto-calculated by Guardrails
    },
  });

  // 2. Create Mind Mesh container (executed second, references subtrack)
  mutations.push({
    type: 'create_integrated_container',
    container: {
      id: containerId,
      workspaceId: context.workspaceId,
      title: intent.name,
      body: intent.description || null,
      isGhost: false,
      xPosition: intent.position.x,
      yPosition: intent.position.y,
      width: intent.width || 300,
      height: intent.height || 200,
      parentContainerId: null,
      metadata: {
        source: 'mind_mesh_creation',
        createdAt: context.timestamp,
      },
    },
    entityType: 'track',
    entityId: subtrackId,
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create integrated subtrack "${intent.name}" under parent ${intent.parentTrackId}`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a promotion from local container to integrated track.
 * Validates container is local-only, then generates plan to create Guardrails track
 * and attach reference to existing container (no new container created).
 */
async function planPromoteContainerToTrackIntent(
  intent: Extract<MindMeshIntent, { type: 'PromoteContainerToTrack' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Require canvas lock for promotion
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to promote container');
    return { success: false, plan: null, errors, warnings };
  }

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container is local-only (not already integrated)
  const reference = context.references.find((r) => r.containerId === intent.containerId && r.isPrimary);
  if (reference) {
    errors.push('Container is already integrated and cannot be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container has title or body
  if (!container.title && !container.body) {
    errors.push('Container must have title or body to be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Use provided name or default to container title
  const trackName = intent.trackName || container.title || container.body || '';
  if (!trackName.trim()) {
    errors.push('Track name cannot be empty');
    return { success: false, plan: null, errors, warnings };
  }

  const trackDescription = intent.trackDescription || container.body || undefined;

  // Validate against Guardrails constraints
  const validation = await validateIntegratedTrackCreation({
    masterProjectId: context.workspace.masterProjectId,
    name: trackName,
    description: trackDescription,
    color: intent.trackColor,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Generate track ID
  const trackId = `track-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails track
  mutations.push({
    type: 'create_guardrails_track',
    track: {
      id: trackId,
      masterProjectId: context.workspace.masterProjectId,
      parentTrackId: null,
      name: trackName,
      description: trackDescription || null,
      color: intent.trackColor || null,
      orderingIndex: 0,
    },
  });

  // 2. Update container to mark as integrated
  mutations.push({
    type: 'update_container',
    containerId: intent.containerId,
    updates: {
      title: trackName,
      body: trackDescription || container.body,
    },
  });

  // 3. Attach reference to link container to track
  mutations.push({
    type: 'attach_container_reference',
    containerId: intent.containerId,
    entityType: 'track',
    entityId: trackId,
    isPrimary: true,
    metadata: {
      source: 'mind_mesh_promotion',
      promotedAt: context.timestamp,
    },
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Promote container ${intent.containerId} to track "${trackName}"`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a promotion from local container to integrated subtrack.
 * Validates container is local-only and parent track exists, then generates plan
 * to create Guardrails subtrack and attach reference to existing container.
 */
async function planPromoteContainerToSubtrackIntent(
  intent: Extract<MindMeshIntent, { type: 'PromoteContainerToSubtrack' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Require canvas lock for promotion
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to promote container');
    return { success: false, plan: null, errors, warnings };
  }

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container is local-only
  const reference = context.references.find((r) => r.containerId === intent.containerId && r.isPrimary);
  if (reference) {
    errors.push('Container is already integrated and cannot be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container has title or body
  if (!container.title && !container.body) {
    errors.push('Container must have title or body to be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Use provided name or default to container title
  const subtrackName = intent.subtrackName || container.title || container.body || '';
  if (!subtrackName.trim()) {
    errors.push('Subtrack name cannot be empty');
    return { success: false, plan: null, errors, warnings };
  }

  const subtrackDescription = intent.subtrackDescription || container.body || undefined;

  // Validate against Guardrails constraints
  const validation = await validateIntegratedSubtrackCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    name: subtrackName,
    description: subtrackDescription,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Generate subtrack ID
  const subtrackId = `track-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails subtrack
  mutations.push({
    type: 'create_guardrails_track',
    track: {
      id: subtrackId,
      masterProjectId: context.workspace.masterProjectId,
      parentTrackId: intent.parentTrackId,
      name: subtrackName,
      description: subtrackDescription || null,
      color: null,
      orderingIndex: 0,
    },
  });

  // 2. Update container to mark as integrated
  mutations.push({
    type: 'update_container',
    containerId: intent.containerId,
    updates: {
      title: subtrackName,
      body: subtrackDescription || container.body,
    },
  });

  // 3. Attach reference to link container to subtrack
  mutations.push({
    type: 'attach_container_reference',
    containerId: intent.containerId,
    entityType: 'track',
    entityId: subtrackId,
    isPrimary: true,
    metadata: {
      source: 'mind_mesh_promotion',
      promotedAt: context.timestamp,
    },
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Promote container ${intent.containerId} to subtrack "${subtrackName}" under parent ${intent.parentTrackId}`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a create integrated task intent.
 * Validates against Guardrails constraints, then generates plan for
 * Guardrails roadmap_item creation, Mind Mesh container creation, and composition relationship.
 */
async function planCreateIntegratedTaskIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateIntegratedTask' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validate against Guardrails constraints
  const validation = await validateIntegratedTaskCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    title: intent.title,
    description: intent.description,
    dueAt: intent.dueAt,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Require canvas lock
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to create integrated task');
    return { success: false, plan: null, errors, warnings };
  }

  // Generate unique IDs
  const taskId = `roadmap-item-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  const containerId = `container-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails roadmap_item (task type)
  mutations.push({
    type: 'create_guardrails_roadmap_item',
    item: {
      id: taskId,
      trackId: intent.parentTrackId,
      title: intent.title,
      description: intent.description || null,
      type: 'task',
      status: 'pending',
      dueAt: intent.dueAt || null,
    },
  });

  // 2. Create Mind Mesh container
  mutations.push({
    type: 'create_integrated_container',
    container: {
      id: containerId,
      workspaceId: context.workspaceId,
      title: intent.title,
      body: intent.description || null,
      isGhost: false,
      xPosition: intent.position.x,
      yPosition: intent.position.y,
      width: intent.width || 300,
      height: intent.height || 150,
      parentContainerId: null,
      metadata: {
        source: 'mind_mesh_creation',
        createdAt: context.timestamp,
        status: 'pending',
        dueAt: intent.dueAt,
      },
    },
    entityType: 'roadmap_item',
    entityId: taskId,
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create integrated task "${intent.title}" at (${intent.position.x}, ${intent.position.y})`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a create integrated event intent.
 * Validates against Guardrails constraints, then generates plan for
 * Guardrails roadmap_item creation, Mind Mesh container creation, and composition relationship.
 */
async function planCreateIntegratedEventIntent(
  intent: Extract<MindMeshIntent, { type: 'CreateIntegratedEvent' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Validate against Guardrails constraints
  const validation = await validateIntegratedEventCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    title: intent.title,
    description: intent.description,
    startsAt: intent.startsAt,
    endsAt: intent.endsAt,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Require canvas lock
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to create integrated event');
    return { success: false, plan: null, errors, warnings };
  }

  // Generate unique IDs
  const eventId = `roadmap-item-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  const containerId = `container-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails roadmap_item (event type)
  mutations.push({
    type: 'create_guardrails_roadmap_item',
    item: {
      id: eventId,
      trackId: intent.parentTrackId,
      title: intent.title,
      description: intent.description || null,
      type: 'event',
      status: 'pending',
      startsAt: intent.startsAt,
      endsAt: intent.endsAt || null,
    },
  });

  // 2. Create Mind Mesh container
  mutations.push({
    type: 'create_integrated_container',
    container: {
      id: containerId,
      workspaceId: context.workspaceId,
      title: intent.title,
      body: intent.description || null,
      isGhost: false,
      xPosition: intent.position.x,
      yPosition: intent.position.y,
      width: intent.width || 300,
      height: intent.height || 150,
      parentContainerId: null,
      metadata: {
        source: 'mind_mesh_creation',
        createdAt: context.timestamp,
        status: 'pending',
        startsAt: intent.startsAt,
        endsAt: intent.endsAt,
      },
    },
    entityType: 'roadmap_item',
    entityId: eventId,
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Create integrated event "${intent.title}" at (${intent.position.x}, ${intent.position.y})`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a promotion from local container to integrated task.
 */
async function planPromoteContainerToTaskIntent(
  intent: Extract<MindMeshIntent, { type: 'PromoteContainerToTask' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Require canvas lock
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to promote container');
    return { success: false, plan: null, errors, warnings };
  }

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container is local-only
  const reference = context.references.find((r) => r.containerId === intent.containerId && r.isPrimary);
  if (reference) {
    errors.push('Container is already integrated and cannot be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container has title or body
  if (!container.title && !container.body) {
    errors.push('Container must have title or body to be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Use provided title or default to container title
  const taskTitle = intent.taskTitle || container.title || container.body || '';
  if (!taskTitle.trim()) {
    errors.push('Task title cannot be empty');
    return { success: false, plan: null, errors, warnings };
  }

  const taskDescription = intent.taskDescription || container.body || undefined;

  // Validate against Guardrails constraints
  const validation = await validateIntegratedTaskCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    title: taskTitle,
    description: taskDescription,
    dueAt: intent.dueAt,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Generate task ID
  const taskId = `roadmap-item-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails roadmap_item
  mutations.push({
    type: 'create_guardrails_roadmap_item',
    item: {
      id: taskId,
      trackId: intent.parentTrackId,
      title: taskTitle,
      description: taskDescription || null,
      type: 'task',
      status: 'pending',
      dueAt: intent.dueAt || null,
    },
  });

  // 2. Update container
  mutations.push({
    type: 'update_container',
    containerId: intent.containerId,
    updates: {
      title: taskTitle,
      body: taskDescription || container.body,
      metadata: {
        ...(container.metadata || {}),
        status: 'pending',
        dueAt: intent.dueAt,
      },
    },
  });

  // 3. Attach reference
  mutations.push({
    type: 'attach_container_reference',
    containerId: intent.containerId,
    entityType: 'roadmap_item',
    entityId: taskId,
    isPrimary: true,
    metadata: {
      source: 'mind_mesh_promotion',
      promotedAt: context.timestamp,
    },
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Promote container ${intent.containerId} to task "${taskTitle}"`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

/**
 * Plans a promotion from local container to integrated event.
 */
async function planPromoteContainerToEventIntent(
  intent: Extract<MindMeshIntent, { type: 'PromoteContainerToEvent' }>,
  context: PlanContext
): Promise<PlanResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Require canvas lock
  if (!context.currentLock || context.currentLock.userId !== context.userId) {
    errors.push('Canvas lock required to promote container');
    return { success: false, plan: null, errors, warnings };
  }

  // Find container
  const container = context.containers.find((c) => c.id === intent.containerId);
  if (!container) {
    errors.push(`Container not found: ${intent.containerId}`);
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container is local-only
  const reference = context.references.find((r) => r.containerId === intent.containerId && r.isPrimary);
  if (reference) {
    errors.push('Container is already integrated and cannot be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Validate container has title or body
  if (!container.title && !container.body) {
    errors.push('Container must have title or body to be promoted');
    return { success: false, plan: null, errors, warnings };
  }

  // Use provided title or default to container title
  const eventTitle = intent.eventTitle || container.title || container.body || '';
  if (!eventTitle.trim()) {
    errors.push('Event title cannot be empty');
    return { success: false, plan: null, errors, warnings };
  }

  const eventDescription = intent.eventDescription || container.body || undefined;

  // Validate against Guardrails constraints
  const validation = await validateIntegratedEventCreation({
    masterProjectId: context.workspace.masterProjectId,
    parentTrackId: intent.parentTrackId,
    title: eventTitle,
    description: eventDescription,
    startsAt: intent.startsAt,
    endsAt: intent.endsAt,
  });

  if (!validation.valid) {
    errors.push(...validation.errors);
    return { success: false, plan: null, errors, warnings };
  }

  warnings.push(...validation.warnings);

  // Generate event ID
  const eventId = `roadmap-item-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  const mutations: PlanMutation[] = [];

  // 1. Create Guardrails roadmap_item
  mutations.push({
    type: 'create_guardrails_roadmap_item',
    item: {
      id: eventId,
      trackId: intent.parentTrackId,
      title: eventTitle,
      description: eventDescription || null,
      type: 'event',
      status: 'pending',
      startsAt: intent.startsAt,
      endsAt: intent.endsAt || null,
    },
  });

  // 2. Update container
  mutations.push({
    type: 'update_container',
    containerId: intent.containerId,
    updates: {
      title: eventTitle,
      body: eventDescription || container.body,
      metadata: {
        ...(container.metadata || {}),
        status: 'pending',
        startsAt: intent.startsAt,
        endsAt: intent.endsAt,
      },
    },
  });

  // 3. Attach reference
  mutations.push({
    type: 'attach_container_reference',
    containerId: intent.containerId,
    entityType: 'roadmap_item',
    entityId: eventId,
    isPrimary: true,
    metadata: {
      source: 'mind_mesh_promotion',
      promotedAt: context.timestamp,
    },
  });

  const plan: MindMeshPlan = {
    id: generatePlanId(),
    workspaceId: context.workspaceId,
    mutations,
    description: `Promote container ${intent.containerId} to event "${eventTitle}"`,
    eventsToEmit: [],
  };

  return { success: true, plan, errors, warnings };
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Generates a unique plan ID.
 * Format: plan_<timestamp>_<random>
 */
function generatePlanId(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 9);
  return `plan_${timestamp}_${random}`;
}
