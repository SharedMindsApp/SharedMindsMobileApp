/**
 * Mind Mesh V2 Canvas Interaction Logic
 *
 * Translates user actions into state transitions.
 * Answers: What happened? What should change? What is now allowed/blocked?
 *
 * CRITICAL: This is logic-only, not UI or rendering.
 *
 * Key Responsibilities:
 * - Detect explicit user intent
 * - Activate ghost containers safely
 * - Enforce nesting rules
 * - Respect canvas locks
 * - Transition layout state correctly
 * - Emit internal interaction events
 *
 * This is a domain controller, not a UI handler.
 */

import type {
  MindMeshWorkspace,
  MindMeshContainer,
  MindMeshContainerReference,
  MindMeshPort,
  MindMeshNode,
  MindMeshCanvasLock,
} from './types';

import {
  validateContainerNesting,
  validateNodeCreation,
  validateLockAcquisition,
  validateWritePermission,
  isLockExpired,
  isLockHolder,
} from './validation';

import {
  markDefaultLayoutBroken,
  isLayoutBreakingEvent,
  type LayoutBreakEvent,
} from './layout';

// ============================================================================
// TYPES
// ============================================================================

/**
 * Reason for activating a ghost container
 */
export type ActivationReason =
  | 'user_drag'
  | 'user_connect_node'
  | 'user_nest'
  | 'user_explicit'
  | 'cascade_from_parent';

/**
 * Result of activation attempt
 */
export interface ActivationResult {
  success: boolean;
  containerId: string;
  wasGhost: boolean;
  reason: ActivationReason;
  layoutBroken: boolean;
  errors: string[];
}

/**
 * Container position update
 */
export interface PositionUpdate {
  containerId: string;
  xPosition: number;
  yPosition: number;
  previousX: number;
  previousY: number;
}

/**
 * Container dimension update
 */
export interface DimensionUpdate {
  containerId: string;
  width: number;
  height: number;
  previousWidth: number;
  previousHeight: number;
}

/**
 * Nesting operation
 */
export interface NestingOperation {
  childId: string;
  parentId: string | null;
  previousParentId: string | null;
}

/**
 * Internal interaction events (not persisted yet)
 * These are for future Regulation integration
 */
export type InteractionEvent =
  | {
      type: 'container_activated';
      containerId: string;
      reason: ActivationReason;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'container_moved';
      containerId: string;
      fromPosition: { x: number; y: number };
      toPosition: { x: number; y: number };
      timestamp: string;
      userId: string;
    }
  | {
      type: 'container_resized';
      containerId: string;
      fromDimensions: { width: number; height: number };
      toDimensions: { width: number; height: number };
      timestamp: string;
      userId: string;
    }
  | {
      type: 'container_nested';
      childId: string;
      parentId: string | null;
      previousParentId: string | null;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'node_created';
      nodeId: string;
      sourcePortId: string;
      targetPortId: string;
      isAutoGenerated: boolean;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'node_deleted';
      nodeId: string;
      wasAutoGenerated: boolean;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'layout_broken';
      workspaceId: string;
      breakEvent: LayoutBreakEvent;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'lock_acquired';
      workspaceId: string;
      timestamp: string;
      userId: string;
    }
  | {
      type: 'lock_released';
      workspaceId: string;
      timestamp: string;
      userId: string;
    };

/**
 * Interaction event listener callback
 */
export type InteractionEventListener = (event: InteractionEvent) => void;

// ============================================================================
// EVENT EMITTER (INTERNAL)
// ============================================================================

/**
 * Simple event emitter for interaction events.
 * Not persisted to database yet - just in-memory for future Regulation.
 */
class InteractionEventEmitter {
  private listeners: InteractionEventListener[] = [];

  subscribe(listener: InteractionEventListener): () => void {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }

  emit(event: InteractionEvent): void {
    for (const listener of this.listeners) {
      try {
        listener(event);
      } catch (error) {
        console.error('Interaction event listener error:', error);
      }
    }
  }

  clearAll(): void {
    this.listeners = [];
  }
}

export const interactionEvents = new InteractionEventEmitter();

// ============================================================================
// CONTAINER ACTIVATION LOGIC
// ============================================================================

/**
 * Checks if a container can be activated.
 * Ghost containers can be activated, active containers cannot be re-activated.
 *
 * @param container - Container to check
 * @param userId - User attempting activation
 * @param currentLock - Current canvas lock (if any)
 * @returns Validation result
 */
export function canActivateContainer(
  container: MindMeshContainer,
  userId: string,
  currentLock: MindMeshCanvasLock | null
): { allowed: boolean; reason?: string } {
  // Check if already active
  if (!container.isGhost) {
    return { allowed: false, reason: 'Container is already active' };
  }

  // Check canvas lock
  const lockCheck = validateWritePermission(
    container.workspaceId,
    userId,
    currentLock
  );

  if (!lockCheck.valid) {
    return { allowed: false, reason: lockCheck.errors[0].message };
  }

  return { allowed: true };
}

/**
 * Plans activation of a ghost container.
 * Activation is always explicit - triggered by user action.
 *
 * Activation reasons:
 * - user_drag: User started dragging the ghost
 * - user_connect_node: User connected a node to/from the ghost
 * - user_nest: User nested something into the ghost
 * - user_explicit: User clicked "Activate" button
 * - cascade_from_parent: Parent was nested, activating child
 *
 * Effects:
 * - Sets isGhost = false
 * - Breaks default layout (if not already broken)
 * - Emits activation event
 *
 * @param container - Container to activate
 * @param reason - Why activation is happening
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Activation plan
 */
export function planContainerActivation(
  container: MindMeshContainer,
  reason: ActivationReason,
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  containerUpdate: { containerId: string; updates: Partial<MindMeshContainer> } | null;
  workspaceUpdate: Partial<MindMeshWorkspace> | null;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check if activation is allowed
  const canActivate = canActivateContainer(container, userId, currentLock);
  if (!canActivate.allowed) {
    errors.push(canActivate.reason || 'Cannot activate container');
    return { containerUpdate: null, workspaceUpdate: null, event: null, errors };
  }

  // Plan container update
  const containerUpdate = {
    containerId: container.id,
    updates: {
      isGhost: false,
    },
  };

  // Check if activation breaks layout
  // Activation is a layout-breaking event (user taking control)
  let workspaceUpdate: Partial<MindMeshWorkspace> | null = null;
  let layoutBroken = false;

  if (!workspace.hasBrokenDefaultLayout) {
    // Activation breaks layout
    workspaceUpdate = markDefaultLayoutBroken(workspace);
    layoutBroken = true;
  }

  // Create activation event
  const event: InteractionEvent = {
    type: 'container_activated',
    containerId: container.id,
    reason,
    timestamp: new Date().toISOString(),
    userId,
  };

  return { containerUpdate, workspaceUpdate, event, errors };
}

/**
 * Checks if activating a container would cascade to children.
 * When nesting a ghost into another container, both should activate.
 *
 * @param containerId - Container being activated
 * @param allContainers - All containers in workspace
 * @returns IDs of containers that would cascade activate
 */
export function getCascadeActivationTargets(
  containerId: string,
  allContainers: MindMeshContainer[]
): string[] {
  const targets: string[] = [];

  // Find all children of this container
  for (const container of allContainers) {
    if (container.parentContainerId === containerId && container.isGhost) {
      targets.push(container.id);
      // Recursively check children of children
      targets.push(...getCascadeActivationTargets(container.id, allContainers));
    }
  }

  return targets;
}

// ============================================================================
// CONTAINER MOVEMENT & RESIZE LOGIC
// ============================================================================

/**
 * Plans a container position update.
 * Moving a container:
 * - Requires canvas lock
 * - Breaks default layout (if not already broken)
 * - Activates ghost if involved
 *
 * @param container - Container to move
 * @param newPosition - New position
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Movement plan
 */
export function planContainerMove(
  container: MindMeshContainer,
  newPosition: { x: number; y: number },
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  containerUpdate: { containerId: string; updates: Partial<MindMeshContainer> } | null;
  workspaceUpdate: Partial<MindMeshWorkspace> | null;
  activationPlan: ReturnType<typeof planContainerActivation> | null;
  event: InteractionEvent | null;
  layoutBreakEvent: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(
    container.workspaceId,
    userId,
    currentLock
  );

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return {
      containerUpdate: null,
      workspaceUpdate: null,
      activationPlan: null,
      event: null,
      layoutBreakEvent: null,
      errors,
    };
  }

  // Check if position actually changed
  if (container.xPosition === newPosition.x && container.yPosition === newPosition.y) {
    // No change, no-op
    return {
      containerUpdate: null,
      workspaceUpdate: null,
      activationPlan: null,
      event: null,
      layoutBreakEvent: null,
      errors: [],
    };
  }

  // Plan activation if ghost
  let activationPlan: ReturnType<typeof planContainerActivation> | null = null;
  if (container.isGhost) {
    activationPlan = planContainerActivation(
      container,
      'user_drag',
      userId,
      workspace,
      currentLock
    );
    if (activationPlan.errors.length > 0) {
      errors.push(...activationPlan.errors);
      return {
        containerUpdate: null,
        workspaceUpdate: null,
        activationPlan: null,
        event: null,
        layoutBreakEvent: null,
        errors,
      };
    }
  }

  // Plan position update
  const containerUpdate = {
    containerId: container.id,
    updates: {
      xPosition: newPosition.x,
      yPosition: newPosition.y,
    },
  };

  // Check if this breaks layout
  let workspaceUpdate: Partial<MindMeshWorkspace> | null = null;
  let layoutBreakEvent: InteractionEvent | null = null;

  if (!workspace.hasBrokenDefaultLayout) {
    // Check if this is a layout-breaking move
    const breaksLayout = isLayoutBreakingEvent('manual_container_move', {
      container,
      previousPosition: { x: container.xPosition, y: container.yPosition },
      newPosition,
    });

    if (breaksLayout) {
      workspaceUpdate = markDefaultLayoutBroken(workspace);
      layoutBreakEvent = {
        type: 'layout_broken',
        workspaceId: workspace.id,
        breakEvent: 'manual_container_move',
        timestamp: new Date().toISOString(),
        userId,
      };
    }
  }

  // Create move event
  const event: InteractionEvent = {
    type: 'container_moved',
    containerId: container.id,
    fromPosition: { x: container.xPosition, y: container.yPosition },
    toPosition: newPosition,
    timestamp: new Date().toISOString(),
    userId,
  };

  return {
    containerUpdate,
    workspaceUpdate,
    activationPlan,
    event,
    layoutBreakEvent,
    errors,
  };
}

/**
 * Plans a container dimension update.
 * Resizing a container:
 * - Requires canvas lock
 * - Does NOT break layout (visual only)
 * - Activates ghost if involved
 *
 * @param container - Container to resize
 * @param newDimensions - New dimensions
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Resize plan
 */
export function planContainerResize(
  container: MindMeshContainer,
  newDimensions: { width: number; height: number },
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  containerUpdate: { containerId: string; updates: Partial<MindMeshContainer> } | null;
  activationPlan: ReturnType<typeof planContainerActivation> | null;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(
    container.workspaceId,
    userId,
    currentLock
  );

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return { containerUpdate: null, activationPlan: null, event: null, errors };
  }

  // Validate dimensions
  if (newDimensions.width <= 0 || newDimensions.height <= 0) {
    errors.push('Dimensions must be positive');
    return { containerUpdate: null, activationPlan: null, event: null, errors };
  }

  // Check if dimensions actually changed
  if (
    (container.width || 0) === newDimensions.width &&
    (container.height || 0) === newDimensions.height
  ) {
    // No change, no-op
    return { containerUpdate: null, activationPlan: null, event: null, errors: [] };
  }

  // Plan activation if ghost
  let activationPlan: ReturnType<typeof planContainerActivation> | null = null;
  if (container.isGhost) {
    activationPlan = planContainerActivation(
      container,
      'user_explicit',
      userId,
      workspace,
      currentLock
    );
    if (activationPlan.errors.length > 0) {
      errors.push(...activationPlan.errors);
      return { containerUpdate: null, activationPlan: null, event: null, errors };
    }
  }

  // Plan dimension update
  const containerUpdate = {
    containerId: container.id,
    updates: {
      width: newDimensions.width,
      height: newDimensions.height,
    },
  };

  // Create resize event
  const event: InteractionEvent = {
    type: 'container_resized',
    containerId: container.id,
    fromDimensions: {
      width: container.width || 0,
      height: container.height || 0,
    },
    toDimensions: newDimensions,
    timestamp: new Date().toISOString(),
    userId,
  };

  return { containerUpdate, activationPlan, event, errors };
}

// ============================================================================
// NESTING & UN-NESTING LOGIC
// ============================================================================

/**
 * Plans nesting a container under a parent.
 * Nesting:
 * - Requires canvas lock
 * - Must pass validation (no cycles)
 * - Activates ghost containers involved
 * - Breaks layout if non-default nesting
 *
 * @param child - Container to nest
 * @param parent - Parent container (or null to un-nest)
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param allContainers - All containers in workspace
 * @param currentLock - Current canvas lock
 * @returns Nesting plan
 */
export function planContainerNesting(
  child: MindMeshContainer,
  parent: MindMeshContainer | null,
  userId: string,
  workspace: MindMeshWorkspace,
  allContainers: MindMeshContainer[],
  currentLock: MindMeshCanvasLock | null
): {
  childUpdate: { containerId: string; updates: Partial<MindMeshContainer> } | null;
  workspaceUpdate: Partial<MindMeshWorkspace> | null;
  childActivation: ReturnType<typeof planContainerActivation> | null;
  parentActivation: ReturnType<typeof planContainerActivation> | null;
  event: InteractionEvent | null;
  layoutBreakEvent: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(child.workspaceId, userId, currentLock);

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return {
      childUpdate: null,
      workspaceUpdate: null,
      childActivation: null,
      parentActivation: null,
      event: null,
      layoutBreakEvent: null,
      errors,
    };
  }

  const newParentId = parent?.id || null;

  // Check if nesting actually changed
  if (child.parentContainerId === newParentId) {
    // No change, no-op
    return {
      childUpdate: null,
      workspaceUpdate: null,
      childActivation: null,
      parentActivation: null,
      event: null,
      layoutBreakEvent: null,
      errors: [],
    };
  }

  // Build hierarchy for validation
  const hierarchy = new Map<string, string | null>();
  for (const container of allContainers) {
    if (container.id === child.id) {
      // Use new parent for this container
      hierarchy.set(container.id, newParentId);
    } else {
      hierarchy.set(container.id, container.parentContainerId);
    }
  }

  // Validate nesting (no cycles)
  if (newParentId !== null) {
    const validation = validateContainerNesting(child.id, newParentId, hierarchy);
    if (!validation.valid) {
      errors.push(validation.errors[0].message);
      return {
        childUpdate: null,
        workspaceUpdate: null,
        childActivation: null,
        parentActivation: null,
        event: null,
        layoutBreakEvent: null,
        errors,
      };
    }
  }

  // Plan activation for child if ghost
  let childActivation: ReturnType<typeof planContainerActivation> | null = null;
  if (child.isGhost) {
    childActivation = planContainerActivation(
      child,
      'user_nest',
      userId,
      workspace,
      currentLock
    );
    if (childActivation.errors.length > 0) {
      errors.push(...childActivation.errors);
      return {
        childUpdate: null,
        workspaceUpdate: null,
        childActivation: null,
        parentActivation: null,
        event: null,
        layoutBreakEvent: null,
        errors,
      };
    }
  }

  // Plan activation for parent if ghost
  let parentActivation: ReturnType<typeof planContainerActivation> | null = null;
  if (parent && parent.isGhost) {
    parentActivation = planContainerActivation(
      parent,
      'user_nest',
      userId,
      workspace,
      currentLock
    );
    if (parentActivation.errors.length > 0) {
      errors.push(...parentActivation.errors);
      return {
        childUpdate: null,
        workspaceUpdate: null,
        childActivation: null,
        parentActivation: null,
        event: null,
        layoutBreakEvent: null,
        errors,
      };
    }
  }

  // Plan nesting update
  const childUpdate = {
    containerId: child.id,
    updates: {
      parentContainerId: newParentId,
    },
  };

  // Check if this breaks layout
  let workspaceUpdate: Partial<MindMeshWorkspace> | null = null;
  let layoutBreakEvent: InteractionEvent | null = null;

  if (!workspace.hasBrokenDefaultLayout) {
    // Check if this is a layout-breaking nest
    const breaksLayout = isLayoutBreakingEvent('manual_container_nesting', {
      container: child,
      previousParent: child.parentContainerId,
      newParent: newParentId,
    });

    if (breaksLayout) {
      workspaceUpdate = markDefaultLayoutBroken(workspace);
      layoutBreakEvent = {
        type: 'layout_broken',
        workspaceId: workspace.id,
        breakEvent: 'manual_container_nesting',
        timestamp: new Date().toISOString(),
        userId,
      };
    }
  }

  // Create nesting event
  const event: InteractionEvent = {
    type: 'container_nested',
    childId: child.id,
    parentId: newParentId,
    previousParentId: child.parentContainerId,
    timestamp: new Date().toISOString(),
    userId,
  };

  return {
    childUpdate,
    workspaceUpdate,
    childActivation,
    parentActivation,
    event,
    layoutBreakEvent,
    errors,
  };
}

/**
 * Plans un-nesting a container (restoring to root level).
 * Un-nesting:
 * - Sets parentContainerId to null
 * - Does not delete nodes
 * - Breaks layout if non-default
 *
 * @param child - Container to un-nest
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param allContainers - All containers in workspace
 * @param currentLock - Current canvas lock
 * @returns Un-nesting plan
 */
export function planContainerUnnesting(
  child: MindMeshContainer,
  userId: string,
  workspace: MindMeshWorkspace,
  allContainers: MindMeshContainer[],
  currentLock: MindMeshCanvasLock | null
): ReturnType<typeof planContainerNesting> {
  // Un-nesting is just nesting with parent = null
  return planContainerNesting(child, null, userId, workspace, allContainers, currentLock);
}

// ============================================================================
// NODE INTERACTION LOGIC (MANUAL)
// ============================================================================

/**
 * Plans creation of a manual node.
 * Creating a manual node:
 * - Requires canvas lock
 * - Validates ports exist, same workspace, not self-connection
 * - Activates ghost containers if involved
 * - Does NOT break layout (nodes are structural, not positional)
 *
 * @param sourcePort - Source port
 * @param targetPort - Target port
 * @param sourceContainer - Source container
 * @param targetContainer - Target container
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Node creation plan
 */
export function planManualNodeCreation(
  sourcePort: MindMeshPort,
  targetPort: MindMeshPort,
  sourceContainer: MindMeshContainer,
  targetContainer: MindMeshContainer,
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  nodeInput: {
    workspaceId: string;
    sourcePortId: string;
    targetPortId: string;
    isAutoGenerated: false;
    relationshipType?: string;
    metadata?: Record<string, unknown>;
  } | null;
  sourceActivation: ReturnType<typeof planContainerActivation> | null;
  targetActivation: ReturnType<typeof planContainerActivation> | null;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(workspace.id, userId, currentLock);

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return {
      nodeInput: null,
      sourceActivation: null,
      targetActivation: null,
      event: null,
      errors,
    };
  }

  // Validate node creation
  const validation = validateNodeCreation(
    {
      workspaceId: workspace.id,
      sourcePortId: sourcePort.id,
      targetPortId: targetPort.id,
      isAutoGenerated: false,
    },
    sourcePort,
    targetPort,
    sourceContainer,
    targetContainer
  );

  if (!validation.valid) {
    errors.push(validation.errors[0].message);
    return {
      nodeInput: null,
      sourceActivation: null,
      targetActivation: null,
      event: null,
      errors,
    };
  }

  // Plan activation for source container if ghost
  let sourceActivation: ReturnType<typeof planContainerActivation> | null = null;
  if (sourceContainer.isGhost) {
    sourceActivation = planContainerActivation(
      sourceContainer,
      'user_connect_node',
      userId,
      workspace,
      currentLock
    );
    if (sourceActivation.errors.length > 0) {
      errors.push(...sourceActivation.errors);
      return {
        nodeInput: null,
        sourceActivation: null,
        targetActivation: null,
        event: null,
        errors,
      };
    }
  }

  // Plan activation for target container if ghost
  let targetActivation: ReturnType<typeof planContainerActivation> | null = null;
  if (targetContainer.isGhost) {
    targetActivation = planContainerActivation(
      targetContainer,
      'user_connect_node',
      userId,
      workspace,
      currentLock
    );
    if (targetActivation.errors.length > 0) {
      errors.push(...targetActivation.errors);
      return {
        nodeInput: null,
        sourceActivation: null,
        targetActivation: null,
        event: null,
        errors,
      };
    }
  }

  // Plan node creation
  const nodeInput = {
    workspaceId: workspace.id,
    sourcePortId: sourcePort.id,
    targetPortId: targetPort.id,
    isAutoGenerated: false as const,
  };

  // Note: nodeId will be assigned by database
  // For event, we'll emit after creation with actual ID
  const event = null; // Emit after node is created with real ID

  return {
    nodeInput,
    sourceActivation,
    targetActivation,
    event,
    errors,
  };
}

/**
 * Plans deletion of a node.
 * Deleting a node:
 * - Requires canvas lock
 * - Auto-generated nodes cannot be deleted (only hidden)
 * - Manual nodes can be freely deleted
 * - Does not delete containers
 *
 * @param node - Node to delete
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Deletion plan
 */
export function planNodeDeletion(
  node: MindMeshNode,
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  allowed: boolean;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(workspace.id, userId, currentLock);

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return { allowed: false, event: null, errors };
  }

  // Check if auto-generated
  if (node.isAutoGenerated) {
    errors.push('Cannot delete auto-generated nodes (hide them instead)');
    return { allowed: false, event: null, errors };
  }

  // Create deletion event
  const event: InteractionEvent = {
    type: 'node_deleted',
    nodeId: node.id,
    wasAutoGenerated: node.isAutoGenerated,
    timestamp: new Date().toISOString(),
    userId,
  };

  return { allowed: true, event, errors };
}

/**
 * Plans creation of a manual container (idea or note).
 * Manual containers:
 * - Require canvas lock
 * - Must have at least title or body
 * - Are not ghosts
 * - Do not reference Guardrails entities
 * - Limited to 'idea' or 'note' types
 * - Created at exact position specified
 *
 * @param containerType - Type of manual container
 * @param position - Position for new container
 * @param title - Optional title
 * @param body - Optional body
 * @param userId - User performing action
 * @param workspace - Current workspace
 * @param currentLock - Current canvas lock
 * @returns Container creation plan
 */
export function planManualContainerCreation(
  containerType: 'idea' | 'note',
  position: { x: number; y: number },
  title: string | undefined,
  body: string | undefined,
  userId: string,
  workspace: MindMeshWorkspace,
  currentLock: MindMeshCanvasLock | null
): {
  containerInput: {
    workspaceId: string;
    title: string | null;
    body: string | null;
    isGhost: false;
    xPosition: number;
    yPosition: number;
    width: number;
    height: number;
    metadata: Record<string, unknown>;
  } | null;
  portInput: {
    portType: 'free';
    label: string | null;
  } | null;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check canvas lock
  const lockCheck = validateWritePermission(workspace.id, userId, currentLock);

  if (!lockCheck.valid) {
    errors.push(lockCheck.errors[0].message);
    return {
      containerInput: null,
      portInput: null,
      event: null,
      errors,
    };
  }

  // Validate content (must have title OR body)
  const hasTitle = title && title.trim().length > 0;
  const hasBody = body && body.trim().length > 0;

  if (!hasTitle && !hasBody) {
    errors.push('Container must have at least a title or body');
    return {
      containerInput: null,
      portInput: null,
      event: null,
      errors,
    };
  }

  // Default dimensions based on type
  const width = 300;
  const height = containerType === 'note' ? 250 : 200;

  // Create container input
  const containerInput = {
    workspaceId: workspace.id,
    title: hasTitle ? title!.trim() : null,
    body: hasBody ? body!.trim() : null,
    isGhost: false as const,
    xPosition: Math.round(position.x),
    yPosition: Math.round(position.y),
    width,
    height,
    metadata: {
      containerType,
      manuallyCreated: true,
      createdAt: new Date().toISOString(),
    },
  };

  // Create default port input
  const portInput = {
    portType: 'free' as const,
    label: null,
  };

  // Create event
  const event: InteractionEvent = {
    type: 'manual_container_created',
    containerType,
    position,
    timestamp: new Date().toISOString(),
    userId,
  };

  return {
    containerInput,
    portInput,
    event,
    errors,
  };
}

/**
 * Checks if hiding an auto-generated node would break layout.
 * Hiding hierarchy visualization is a layout-breaking event.
 *
 * @param node - Node being hidden
 * @param workspace - Current workspace
 * @returns Whether hiding breaks layout
 */
export function wouldHidingNodeBreakLayout(
  node: MindMeshNode,
  workspace: MindMeshWorkspace
): boolean {
  // Only auto-generated nodes affect layout
  if (!node.isAutoGenerated) {
    return false;
  }

  // Already broken, no effect
  if (workspace.hasBrokenDefaultLayout) {
    return false;
  }

  // Hiding auto-generated node breaks layout (user rejecting hierarchy viz)
  return true;
}

// ============================================================================
// CANVAS LOCK ENFORCEMENT
// ============================================================================

/**
 * Plans acquisition of canvas lock.
 * Lock acquisition:
 * - Must be explicit
 * - Single user only
 * - Validates duration
 *
 * @param workspaceId - Workspace to lock
 * @param userId - User acquiring lock
 * @param durationMs - Lock duration in milliseconds
 * @param existingLock - Current lock (if any)
 * @returns Lock acquisition plan
 */
export function planCanvasLockAcquisition(
  workspaceId: string,
  userId: string,
  durationMs: number,
  existingLock: MindMeshCanvasLock | null
): {
  lockInput: {
    workspaceId: string;
    userId: string;
    expiresAt: string;
  } | null;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Validate lock acquisition
  const validation = validateLockAcquisition(workspaceId, userId, existingLock, durationMs);

  if (!validation.valid) {
    errors.push(validation.errors[0].message);
    return { lockInput: null, event: null, errors };
  }

  // Calculate expiry
  const expiresAt = new Date(Date.now() + durationMs).toISOString();

  // Plan lock creation
  const lockInput = {
    workspaceId,
    userId,
    expiresAt,
  };

  // Create lock event
  const event: InteractionEvent = {
    type: 'lock_acquired',
    workspaceId,
    timestamp: new Date().toISOString(),
    userId,
  };

  return { lockInput, event, errors };
}

/**
 * Plans release of canvas lock.
 * Lock release:
 * - Must be lock holder or admin
 * - Can be explicit or timeout-based
 *
 * @param lock - Lock to release
 * @param userId - User releasing lock
 * @param isTimeout - Whether release is due to timeout
 * @returns Lock release plan
 */
export function planCanvasLockRelease(
  lock: MindMeshCanvasLock,
  userId: string,
  isTimeout: boolean
): {
  allowed: boolean;
  event: InteractionEvent | null;
  errors: string[];
} {
  const errors: string[] = [];

  // Check if user can release
  if (!isTimeout && !isLockHolder(lock, userId)) {
    errors.push('Only lock holder can release lock');
    return { allowed: false, event: null, errors };
  }

  // Create release event
  const event: InteractionEvent = {
    type: 'lock_released',
    workspaceId: lock.workspaceId,
    timestamp: new Date().toISOString(),
    userId,
  };

  return { allowed: true, event, errors };
}

/**
 * Asserts that user can perform write operations on workspace.
 * All write operations must pass this check.
 *
 * @param workspaceId - Workspace being modified
 * @param userId - User performing operation
 * @param currentLock - Current canvas lock
 * @returns Whether write is allowed
 */
export function assertCanvasWriteAllowed(
  workspaceId: string,
  userId: string,
  currentLock: MindMeshCanvasLock | null
): { allowed: boolean; reason?: string } {
  const validation = validateWritePermission(workspaceId, userId, currentLock);

  if (!validation.valid) {
    return { allowed: false, reason: validation.errors[0].message };
  }

  return { allowed: true };
}

/**
 * Checks if a lock has expired and should be auto-released.
 *
 * @param lock - Lock to check
 * @returns Whether lock has expired
 */
export function shouldAutoReleaseLock(lock: MindMeshCanvasLock): boolean {
  return isLockExpired(lock);
}

// ============================================================================
// INTERACTION HELPERS
// ============================================================================

/**
 * Combines multiple container updates into a single batch.
 * Useful when multiple operations need to be applied together.
 *
 * @param updates - Array of container updates
 * @returns Deduplicated updates
 */
export function batchContainerUpdates(
  updates: Array<{ containerId: string; updates: Partial<MindMeshContainer> }>
): Array<{ containerId: string; updates: Partial<MindMeshContainer> }> {
  const batched = new Map<string, Partial<MindMeshContainer>>();

  for (const update of updates) {
    const existing = batched.get(update.containerId) || {};
    batched.set(update.containerId, { ...existing, ...update.updates });
  }

  return Array.from(batched.entries()).map(([containerId, updates]) => ({
    containerId,
    updates,
  }));
}

/**
 * Extracts all events from multiple operation plans.
 * Useful for collecting events to emit after batch operations.
 *
 * @param plans - Array of operation plans
 * @returns All non-null events
 */
export function collectEvents(
  ...plans: Array<{ event?: InteractionEvent | null; [key: string]: unknown }>
): InteractionEvent[] {
  const events: InteractionEvent[] = [];

  for (const plan of plans) {
    if (plan.event) {
      events.push(plan.event);
    }
  }

  return events;
}

/**
 * Checks if any errors occurred in operation plans.
 *
 * @param plans - Array of operation plans
 * @returns All errors found
 */
export function collectErrors(
  ...plans: Array<{ errors?: string[]; [key: string]: unknown }>
): string[] {
  const errors: string[] = [];

  for (const plan of plans) {
    if (plan.errors && plan.errors.length > 0) {
      errors.push(...plan.errors);
    }
  }

  return errors;
}

/**
 * Determines if an operation would require workspace update.
 * Used to check if layout would break before committing.
 *
 * @param plans - Array of operation plans
 * @returns Whether workspace needs update
 */
export function requiresWorkspaceUpdate(
  ...plans: Array<{ workspaceUpdate?: Partial<MindMeshWorkspace> | null; [key: string]: unknown }>
): boolean {
  for (const plan of plans) {
    if (plan.workspaceUpdate) {
      return true;
    }
  }
  return false;
}

// ============================================================================
// SANITY CHECKS
// ============================================================================

/**
 * Validates that activation is always explicit.
 * Ghost containers should never auto-activate.
 */
export function assertActivationIsExplicit(reason: ActivationReason): boolean {
  // All reasons are explicit user actions
  const validReasons: ActivationReason[] = [
    'user_drag',
    'user_connect_node',
    'user_nest',
    'user_explicit',
    'cascade_from_parent',
  ];

  return validReasons.includes(reason);
}

/**
 * Validates that user actions permanently override auto-layout.
 * Once broken, layout stays broken until explicit reset.
 */
export function assertLayoutBreakIsPermanent(
  workspace: MindMeshWorkspace,
  operation: 'move' | 'nest' | 'activate'
): boolean {
  // If layout is already broken, operation doesn't change state
  if (workspace.hasBrokenDefaultLayout) {
    return true;
  }

  // If layout is intact, breaking operations should mark it broken
  // But that's the responsibility of the calling code
  // This is just a sanity check
  return true;
}

/**
 * Validates that no silent structural changes occur.
 * All changes must be planned and approved.
 */
export function assertNoSilentChanges(
  plan: Record<string, unknown>
): boolean {
  // If plan has updates, they must be explicit (not null/undefined accidentally)
  for (const [key, value] of Object.entries(plan)) {
    if (key.includes('Update') || key.includes('Input')) {
      // Update/Input fields should be explicitly null or defined
      if (value === undefined) {
        console.error(`Silent change detected: ${key} is undefined`);
        return false;
      }
    }
  }

  return true;
}

/**
 * Validates that canvas lock is enforced everywhere.
 * All write operations must check lock.
 */
export function assertLockEnforcementComplete(): boolean {
  // This is a meta-check - in actual use, each function checks lock
  // If this returns false, there's a critical bug
  return true;
}

/**
 * Validates that nodes never gain meaning.
 * Nodes are relationships only, containers are semantic.
 */
export function assertNodesRemainMeaningless(): boolean {
  // Nodes have no title, body, or semantic content
  // This is enforced by validation layer
  // If this ever returns false, there's a critical bug
  return true;
}
