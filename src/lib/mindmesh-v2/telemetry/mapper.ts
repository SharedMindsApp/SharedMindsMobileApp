/**
 * Mind Mesh V2 Telemetry Mapper
 *
 * Converts internal interaction events to privacy-preserving telemetry events.
 *
 * CRITICAL: This is the privacy firewall.
 * - Strips all forbidden fields (content, IDs, references)
 * - Ensures only allowed metadata passes through
 * - Validates output before allowing persistence
 *
 * Prime Rule: If in doubt, strip it out.
 */

import type { InteractionEvent } from '../interactions';
import type {
  TelemetryEvent,
  TelemetryEventType,
  AllowedTelemetryMeta,
} from './types';
import {
  isAllowedEventType,
  validateTelemetryMeta,
  validateTelemetryEvent,
} from './types';

// ============================================================================
// EVENT TYPE MAPPING
// ============================================================================

/**
 * Maps interaction event type to telemetry event type.
 * Returns null if event should not be tracked.
 */
function mapEventType(interactionType: InteractionEvent['type']): TelemetryEventType | null {
  const mapping: Record<string, TelemetryEventType | null> = {
    container_activated: 'ContainerActivated',
    container_moved: 'ContainerMoved',
    container_resized: 'ContainerResized',
    container_nested: 'ContainerNested',
    node_created: 'NodeCreated',
    node_deleted: 'NodeDeleted',
    layout_broken: 'DefaultLayoutBroken',
    lock_acquired: 'CanvasLockAcquired',
    lock_released: 'CanvasLockReleased',
  };

  return mapping[interactionType] || null;
}

// ============================================================================
// METADATA EXTRACTION
// ============================================================================

/**
 * Extracts allowed metadata from container_activated event.
 * Strips all forbidden fields (containerId, etc).
 */
function extractActivationMeta(event: Extract<InteractionEvent, { type: 'container_activated' }>): AllowedTelemetryMeta {
  return {
    // Activation reason is allowed (categorical)
    activationReason: event.reason,
    // Container type is implied (activated = was ghost)
    isGhost: false, // Post-activation state
  };
}

/**
 * Extracts allowed metadata from container_moved event.
 * Strips position data (could reveal layout patterns).
 */
function extractMoveMeta(event: Extract<InteractionEvent, { type: 'container_moved' }>): AllowedTelemetryMeta {
  // No position data stored (privacy)
  // Just record that move happened
  return {};
}

/**
 * Extracts allowed metadata from container_resized event.
 * Strips dimension data (visual only, not semantic).
 */
function extractResizeMeta(event: Extract<InteractionEvent, { type: 'container_resized' }>): AllowedTelemetryMeta {
  // No dimension data stored (privacy)
  // Just record that resize happened
  return {};
}

/**
 * Extracts allowed metadata from container_nested event.
 * Strips all container IDs (cannot reveal hierarchy).
 */
function extractNestingMeta(event: Extract<InteractionEvent, { type: 'container_nested' }>): AllowedTelemetryMeta {
  // No container IDs stored (privacy)
  // Just record that nesting happened
  // Can track if it's un-nesting (parentId = null)
  return {
    // Track nesting vs un-nesting pattern
    relationshipType: event.parentId === null ? 'hierarchy' : 'hierarchy',
  };
}

/**
 * Extracts allowed metadata from node_created event.
 * Strips all port IDs and container IDs (cannot reveal connections).
 */
function extractNodeCreationMeta(event: Extract<InteractionEvent, { type: 'node_created' }>): AllowedTelemetryMeta {
  return {
    // Auto-generated flag is allowed (structural)
    isAutoGenerated: event.isAutoGenerated,
    // No port IDs or container IDs stored (privacy)
  };
}

/**
 * Extracts allowed metadata from node_deleted event.
 * Strips node ID (cannot reveal what was deleted).
 */
function extractNodeDeletionMeta(event: Extract<InteractionEvent, { type: 'node_deleted' }>): AllowedTelemetryMeta {
  return {
    // Was it auto-generated (structural)
    isAutoGenerated: event.wasAutoGenerated,
    // No node ID stored (privacy)
  };
}

/**
 * Extracts allowed metadata from layout_broken event.
 * Strips workspace ID (already in top-level field).
 */
function extractLayoutBreakMeta(event: Extract<InteractionEvent, { type: 'layout_broken' }>): AllowedTelemetryMeta {
  // No specific metadata needed
  // Event type itself is sufficient
  return {};
}

/**
 * Extracts allowed metadata from lock_acquired event.
 * No metadata needed (event type is sufficient).
 */
function extractLockAcquiredMeta(event: Extract<InteractionEvent, { type: 'lock_acquired' }>): AllowedTelemetryMeta {
  return {};
}

/**
 * Extracts allowed metadata from lock_released event.
 * No metadata needed (event type is sufficient).
 */
function extractLockReleasedMeta(event: Extract<InteractionEvent, { type: 'lock_released' }>): AllowedTelemetryMeta {
  return {};
}

// ============================================================================
// MAIN MAPPER
// ============================================================================

/**
 * Maps interaction event to telemetry event.
 *
 * Privacy Firewall:
 * - Strips all forbidden fields
 * - Ensures only allowed metadata passes through
 * - Validates output structure
 * - Returns null if event should not be tracked
 *
 * @param interactionEvent - Internal interaction event
 * @returns Privacy-safe telemetry event or null
 */
export function mapInteractionEventToTelemetry(
  interactionEvent: InteractionEvent
): TelemetryEvent | null {
  // Map event type
  const eventType = mapEventType(interactionEvent.type);
  if (!eventType) {
    // Event type not tracked
    return null;
  }

  // Extract allowed metadata based on event type
  let meta: AllowedTelemetryMeta = {};

  switch (interactionEvent.type) {
    case 'container_activated':
      meta = extractActivationMeta(interactionEvent);
      break;

    case 'container_moved':
      meta = extractMoveMeta(interactionEvent);
      break;

    case 'container_resized':
      meta = extractResizeMeta(interactionEvent);
      break;

    case 'container_nested':
      meta = extractNestingMeta(interactionEvent);
      break;

    case 'node_created':
      meta = extractNodeCreationMeta(interactionEvent);
      break;

    case 'node_deleted':
      meta = extractNodeDeletionMeta(interactionEvent);
      break;

    case 'layout_broken':
      meta = extractLayoutBreakMeta(interactionEvent);
      break;

    case 'lock_acquired':
      meta = extractLockAcquiredMeta(interactionEvent);
      break;

    case 'lock_released':
      meta = extractLockReleasedMeta(interactionEvent);
      break;

    default:
      // Unknown event type
      return null;
  }

  // Validate metadata (defensive check)
  const metaValidation = validateTelemetryMeta(meta as Record<string, unknown>);
  if (!metaValidation.valid) {
    console.error('Telemetry mapping validation failed:', metaValidation.errors);
    return null;
  }

  // Extract workspace ID based on event type
  let workspaceId: string;
  if (interactionEvent.type === 'layout_broken' ||
      interactionEvent.type === 'lock_acquired' ||
      interactionEvent.type === 'lock_released') {
    workspaceId = interactionEvent.workspaceId;
  } else {
    // For other events, workspace ID is not in the event
    // This is a limitation - we need workspace ID to be tracked
    // For now, return null (cannot track without workspace context)
    console.warn('Cannot map event without workspace ID:', interactionEvent.type);
    return null;
  }

  // Create telemetry event
  const telemetryEvent: TelemetryEvent = {
    id: crypto.randomUUID(),
    workspaceId,
    userId: interactionEvent.userId,
    eventType,
    timestamp: interactionEvent.timestamp,
    meta,
  };

  // Final validation
  const validation = validateTelemetryEvent(telemetryEvent);
  if (!validation.valid) {
    console.error('Telemetry event validation failed:', validation.errors);
    return null;
  }

  return telemetryEvent;
}

/**
 * Batch maps multiple interaction events to telemetry events.
 * Filters out null results (events that should not be tracked).
 *
 * @param interactionEvents - Array of interaction events
 * @returns Array of telemetry events (excluding nulls)
 */
export function batchMapInteractionEvents(
  interactionEvents: InteractionEvent[]
): TelemetryEvent[] {
  const telemetryEvents: TelemetryEvent[] = [];

  for (const interactionEvent of interactionEvents) {
    const telemetryEvent = mapInteractionEventToTelemetry(interactionEvent);
    if (telemetryEvent) {
      telemetryEvents.push(telemetryEvent);
    }
  }

  return telemetryEvents;
}

// ============================================================================
// MANUAL EVENT CREATION (for session tracking)
// ============================================================================

/**
 * Creates telemetry event manually (for events not derived from interactions).
 * Used for session tracking (WorkspaceOpened, WorkspaceClosed, etc).
 *
 * @param eventType - Telemetry event type
 * @param workspaceId - Workspace ID
 * @param userId - User ID
 * @param meta - Optional metadata (validated)
 * @returns Telemetry event or null if validation fails
 */
export function createManualTelemetryEvent(
  eventType: TelemetryEventType,
  workspaceId: string,
  userId: string,
  meta: AllowedTelemetryMeta = {}
): TelemetryEvent | null {
  // Validate event type
  if (!isAllowedEventType(eventType)) {
    console.error('Invalid telemetry event type:', eventType);
    return null;
  }

  // Validate metadata
  const metaValidation = validateTelemetryMeta(meta as Record<string, unknown>);
  if (!metaValidation.valid) {
    console.error('Invalid telemetry metadata:', metaValidation.errors);
    return null;
  }

  // Create event
  const telemetryEvent: TelemetryEvent = {
    id: crypto.randomUUID(),
    workspaceId,
    userId,
    eventType,
    timestamp: new Date().toISOString(),
    meta,
  };

  // Final validation
  const validation = validateTelemetryEvent(telemetryEvent);
  if (!validation.valid) {
    console.error('Telemetry event validation failed:', validation.errors);
    return null;
  }

  return telemetryEvent;
}

/**
 * Creates WorkspaceOpened telemetry event.
 */
export function createWorkspaceOpenedEvent(
  workspaceId: string,
  userId: string
): TelemetryEvent | null {
  return createManualTelemetryEvent('WorkspaceOpened', workspaceId, userId);
}

/**
 * Creates WorkspaceClosed telemetry event.
 */
export function createWorkspaceClosedEvent(
  workspaceId: string,
  userId: string,
  sessionDurationMinutes?: number
): TelemetryEvent | null {
  return createManualTelemetryEvent('WorkspaceClosed', workspaceId, userId, {
    sessionDurationMinutes,
  });
}

/**
 * Creates FocusModeEntered telemetry event.
 */
export function createFocusModeEnteredEvent(
  workspaceId: string,
  userId: string
): TelemetryEvent | null {
  return createManualTelemetryEvent('FocusModeEntered', workspaceId, userId);
}

/**
 * Creates FocusModeExited telemetry event.
 */
export function createFocusModeExitedEvent(
  workspaceId: string,
  userId: string,
  sessionDurationMinutes?: number
): TelemetryEvent | null {
  return createManualTelemetryEvent('FocusModeExited', workspaceId, userId, {
    sessionDurationMinutes,
  });
}

// ============================================================================
// PRIVACY ASSERTIONS
// ============================================================================

/**
 * Asserts that telemetry event does not contain forbidden fields.
 * Used in tests and development to catch privacy violations.
 */
export function assertNoForbiddenFields(telemetryEvent: TelemetryEvent): {
  safe: boolean;
  violations: string[];
} {
  const violations: string[] = [];

  // Check for forbidden fields in meta
  const metaStr = JSON.stringify(telemetryEvent.meta);

  // Forbidden keywords that indicate content leakage
  const forbiddenKeywords = [
    'title',
    'body',
    'content',
    'text',
    'label',
    'filename',
    'containerId',
    'nodeId',
    'portId',
    'trackId',
    'taskId',
    'entityId',
    'referenceId',
    'sourcePortId',
    'targetPortId',
    'parentContainerId',
    'childId',
    'fromPosition',
    'toPosition',
    'fromDimensions',
    'toDimensions',
  ];

  for (const keyword of forbiddenKeywords) {
    if (metaStr.toLowerCase().includes(keyword.toLowerCase())) {
      violations.push(`Forbidden keyword detected: ${keyword}`);
    }
  }

  // Check for large metadata (could be hiding content)
  if (metaStr.length > 500) {
    violations.push('Metadata too large (possible content leakage)');
  }

  return {
    safe: violations.length === 0,
    violations,
  };
}

/**
 * Asserts that telemetry event cannot reconstruct relationships.
 * Telemetry should never contain enough information to rebuild the graph.
 */
export function assertCannotReconstructGraph(
  telemetryEvents: TelemetryEvent[]
): {
  safe: boolean;
  violations: string[];
} {
  const violations: string[] = [];

  // Check that no events contain container IDs or node IDs
  for (const event of telemetryEvents) {
    const eventStr = JSON.stringify(event);

    // Should never contain UUID-like strings (indicates ID leakage)
    const uuidPattern = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi;
    const uuidMatches = eventStr.match(uuidPattern);

    if (uuidMatches && uuidMatches.length > 2) {
      // Event ID and workspace ID are allowed (2 UUIDs expected)
      // More than 2 indicates ID leakage
      violations.push(`Event contains suspicious UUIDs: ${event.eventType}`);
    }
  }

  return {
    safe: violations.length === 0,
    violations,
  };
}
