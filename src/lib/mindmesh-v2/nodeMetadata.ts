/**
 * Mind Mesh V2 Node Metadata Service
 *
 * Derives human-readable relationship information from nodes and ports.
 * Used for read-only display in hover previews and inspectors.
 */

import type { MindMeshNode, MindMeshPort, MindMeshContainer } from '../../hooks/useMindMesh';

export type RelationshipType =
  | 'hierarchy'
  | 'dependency'
  | 'reference'
  | 'composition'
  | 'ideation'
  | 'unknown';

export interface NodeMetadata {
  relationshipType: RelationshipType;
  relationshipLabel: string;
  directionLabel: string;
  sourceContainer: {
    title: string;
    entityType: string;
  };
  targetContainer: {
    title: string;
    entityType: string;
  };
  isAutoGenerated: boolean;
  description: string;
}

export function deriveRelationshipType(
  sourcePort: MindMeshPort,
  targetPort: MindMeshPort
): RelationshipType {
  if (sourcePort.direction === 'parent' && targetPort.direction === 'child') {
    if (sourcePort.entity_type === 'track' && targetPort.entity_type === 'roadmap_item') {
      return 'hierarchy';
    }
    if (sourcePort.entity_type === 'roadmap_item' && targetPort.entity_type === 'roadmap_item') {
      return 'composition';
    }
    return 'hierarchy';
  }

  if (sourcePort.direction === 'child' && targetPort.direction === 'parent') {
    return 'hierarchy';
  }

  if (sourcePort.entity_type === 'offshoot' || targetPort.entity_type === 'offshoot') {
    return 'ideation';
  }

  if (sourcePort.entity_type === 'roadmap_item' && targetPort.entity_type === 'roadmap_item') {
    return 'dependency';
  }

  return 'reference';
}

export function getRelationshipLabel(type: RelationshipType): string {
  switch (type) {
    case 'hierarchy':
      return 'Parent-Child';
    case 'dependency':
      return 'Dependency';
    case 'reference':
      return 'Reference';
    case 'composition':
      return 'Composition';
    case 'ideation':
      return 'Ideation';
    case 'unknown':
      return 'Related';
  }
}

export function getRelationshipDescription(
  type: RelationshipType,
  isAutoGenerated: boolean
): string {
  const source = isAutoGenerated
    ? 'This relationship is derived from Guardrails structure.'
    : 'This relationship was created manually in Mind Mesh.';

  const typeDescription = {
    hierarchy: 'A structural parent-child relationship defining ownership or containment.',
    dependency: 'A dependency relationship where one item relies on or blocks another.',
    reference: 'A cross-reference or association between related items.',
    composition: 'A compositional relationship where items combine to form a larger whole.',
    ideation: 'An ideation relationship connecting exploratory thoughts or concepts.',
    unknown: 'A relationship between containers.',
  }[type];

  return `${typeDescription} ${source}`;
}

export function getRelationshipVisualStyle(
  type: RelationshipType,
  isAutoGenerated: boolean
): {
  color: string;
  strokeWidth: number;
  dashArray: string | undefined;
} {
  const baseWidth = isAutoGenerated ? 1 : 2;

  switch (type) {
    case 'hierarchy':
      return {
        color: isAutoGenerated ? '#9ca3af' : '#3b82f6',
        strokeWidth: baseWidth,
        dashArray: isAutoGenerated ? '5,5' : undefined,
      };
    case 'dependency':
      return {
        color: isAutoGenerated ? '#fbbf24' : '#f59e0b',
        strokeWidth: baseWidth,
        dashArray: isAutoGenerated ? '5,5' : undefined,
      };
    case 'reference':
      return {
        color: isAutoGenerated ? '#a78bfa' : '#8b5cf6',
        strokeWidth: baseWidth,
        dashArray: isAutoGenerated ? '5,5' : undefined,
      };
    case 'composition':
      return {
        color: isAutoGenerated ? '#60a5fa' : '#2563eb',
        strokeWidth: baseWidth,
        dashArray: isAutoGenerated ? '5,5' : undefined,
      };
    case 'ideation':
      return {
        color: isAutoGenerated ? '#34d399' : '#10b981',
        strokeWidth: baseWidth,
        dashArray: isAutoGenerated ? '5,5' : undefined,
      };
    case 'unknown':
      return {
        color: '#9ca3af',
        strokeWidth: baseWidth,
        dashArray: '5,5',
      };
  }
}

export function createNodeMetadata(
  node: MindMeshNode,
  sourcePort: MindMeshPort,
  targetPort: MindMeshPort,
  sourceContainer: MindMeshContainer,
  targetContainer: MindMeshContainer,
  sourceTitle: string,
  targetTitle: string
): NodeMetadata {
  const relationshipType = deriveRelationshipType(sourcePort, targetPort);
  const relationshipLabel = getRelationshipLabel(relationshipType);
  const description = getRelationshipDescription(relationshipType, node.source_generated);

  let directionLabel = 'Bidirectional';
  if (sourcePort.direction === 'parent' && targetPort.direction === 'child') {
    directionLabel = `${sourceTitle} → ${targetTitle}`;
  } else if (sourcePort.direction === 'child' && targetPort.direction === 'parent') {
    directionLabel = `${targetTitle} → ${sourceTitle}`;
  }

  return {
    relationshipType,
    relationshipLabel,
    directionLabel,
    sourceContainer: {
      title: sourceTitle,
      entityType: sourcePort.entity_type,
    },
    targetContainer: {
      title: targetTitle,
      entityType: targetPort.entity_type,
    },
    isAutoGenerated: node.source_generated,
    description,
  };
}
