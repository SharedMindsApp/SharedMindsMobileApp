# Mind Mesh V2 Layout System

## Overview

The Mind Mesh V2 layout system is a **deterministic, self-backing-off** auto-layout engine that materializes Guardrails entities as ghost containers and positions them hierarchically—until the user expresses intent to take control.

**Key Principle:** The system applies default layout exactly once, then backs off permanently when the user demonstrates control.

---

## Core Concepts

### 1. Ghost Containers

**Definition:** Ghost containers are read-only Mind Mesh containers that represent the existence of Guardrails entities (tracks, subtracks, roadmap items).

**Properties:**
- `isGhost = true`
- Read-only (no user mutations)
- One container per Guardrails entity (exactly)
- Non-authoritative (deleting ghost never deletes Guardrails entity)

**Purpose:** Ghost containers represent **existence**, not **attention**. They show what exists in Guardrails without claiming user focus.

**Lifecycle:**
1. Guardrails entity created → Ghost container materialised
2. Metadata updated → Ghost container synced
3. Guardrails entity deleted → Ghost container deleted
4. Reference deleted → Ghost container remains (non-authoritative)

---

### 2. Default Hierarchy Layout

**Definition:** Automatic spatial positioning based on Guardrails hierarchy structure.

**Layout Rules:**
```
Tracks (root level)
  → Arranged horizontally with spacing
  → Position: (x: 100 + trackIndex * 400, y: 100)

Subtracks (nested under tracks)
  → Indented under parent track
  → Stacked vertically
  → Position: (x: trackX + 50, y: trackY + 600 + subtIndex * 300)

Roadmap Items (nested under tracks/subtracks)
  → Indented under parent
  → Stacked vertically
  → Position: (x: parentX + 50, y: parentY + spacing + itemIndex * 150)

Sub-items (nested under items)
  → Further indented
  → Position: (x: parentX + 40, y: parentY + spacing + subIndex * 120)
```

**Characteristics:**
- Deterministic (same input = same output)
- Idempotent (can re-run safely)
- Abstract units (not pixel-perfect)
- Hierarchy-based (follows Guardrails structure)

---

### 3. Auto-Generated Hierarchy Nodes

**Definition:** System-created nodes that visualize parent-child composition relationships.

**Properties:**
- `isAutoGenerated = true`
- Connect parent output port → child input port
- Represent composition (not semantic relationships)
- Re-creatable (can delete and regenerate)
- Do NOT store content (only structure)

**Purpose:** Show the Guardrails hierarchy structure visually.

**Example:**
```
Track A (container)
  └─→ [node: composition] → Subtrack B (container)
        └─→ [node: composition] → Item C (container)
```

---

### 4. Layout Break Detection

**Definition:** System that detects when the user takes control of layout.

**Breaking Events:**
1. **Manual container move** - User changes `xPosition` or `yPosition`
2. **Manual container nesting** - User changes `parentContainerId`
3. **Container activation** - User transitions ghost to active (future feature)
4. **Auto-node hidden** - User hides auto-generated hierarchy nodes
5. **Manual layout change** - Any explicit positioning action

**Effect:** Once any breaking event occurs:
```
workspace.hasBrokenDefaultLayout = true  // One-way flag
```

**Permanence:** This flag stays `true` until explicit user reset. No automatic recovery.

---

### 5. Backing Off Behavior

**Definition:** When `hasBrokenDefaultLayout = true`, auto-layout backs off permanently.

**Backing Off Means:**

| Action | When Layout Intact | When Layout Broken |
|--------|-------------------|-------------------|
| New entity added | Auto-positioned hierarchically | Spawns at origin (0, 0) |
| Ghost container created | Auto-nested under parent | Free-floating (no parent) |
| Hierarchy nodes | Auto-generated | Not auto-generated |
| Layout reapplication | Never (unless reset) | Never |
| User positioning | Breaks layout flag | No effect (already broken) |

**Why Back Off?**
- Respects user intent
- Prevents "fighting" the user
- Avoids unexpected repositioning
- Allows free-form canvas use

---

## System Behavior

### Scenario 1: First Materialisation (Intact Layout)

```
1. User creates project in Guardrails
   └─ Track A, Track B created

2. User opens Mind Mesh workspace
   └─ System materializes ghosts:
      - Container for Track A (isGhost=true)
      - Container for Track B (isGhost=true)

3. System applies default layout:
   - Track A at (100, 100)
   - Track B at (500, 100)
   - Auto-generated nodes: none (tracks are root level)

4. workspace.hasBrokenDefaultLayout = false

Result: Clean hierarchy visualization
```

---

### Scenario 2: User Moves a Container (Layout Break)

```
1. Layout is intact (hasBrokenDefaultLayout = false)

2. User drags Track A container
   └─ xPosition changes: 100 → 250

3. System detects: isLayoutBreakingEvent('manual_container_move')
   └─ Returns: true

4. System updates:
   workspace.hasBrokenDefaultLayout = true  // One-way

5. Future behavior changes:
   - New entities spawn at (0, 0)
   - No auto-nesting
   - No auto-generated nodes
   - User has full control

Result: System backs off permanently
```

---

### Scenario 3: Adding Entity After Layout Break

```
1. workspace.hasBrokenDefaultLayout = true  // Already broken

2. User adds Subtrack C to Track A in Guardrails

3. System materializes ghost for Subtrack C:
   - isGhost = true
   - xPosition = 0, yPosition = 0  // Origin, not auto-positioned
   - parentContainerId = null      // Not auto-nested

4. No auto-generated node created

5. User must manually:
   - Position Subtrack C
   - Nest it under Track A (if desired)
   - Create relationship nodes (if desired)

Result: User retains full control
```

---

### Scenario 4: Explicit Layout Reset

```
1. workspace.hasBrokenDefaultLayout = true  // Broken

2. User invokes: "Reset to Default Layout"

3. System executes reset plan:
   a. Recompute hierarchy positions
   b. Update all container positions
   c. Update all container parents (nesting)
   d. Delete old auto-generated nodes
   e. Create new auto-generated nodes
   f. Update workspace:
      - hasBrokenDefaultLayout = false
      - lastLayoutResetAt = now()

4. Future behavior:
   - Auto-layout still won't reapply (flag is false, but not first time)
   - New entities spawn at default positions
   - But no automatic repositioning of existing

5. If user moves anything again:
   - hasBrokenDefaultLayout = true again
   - Backs off again

Result: Clean slate, but user can break again
```

---

## API Reference

### Ghost Materialisation

#### `planGhostMaterialisation()`

Plans creation of ghost containers for Guardrails entities.

**Input:**
- `workspaceId` - Target workspace
- `entities` - Guardrails entities to materialize
- `existingContainers` - Current containers (to avoid duplicates)
- `existingReferences` - Current references (to find existing ghosts)

**Output:**
```typescript
{
  toCreate: CreateMindMeshContainerInput[];  // New ghosts to create
  toUpdate: Array<{ containerId, updates }>;  // Ghosts to sync
  toCreateReferences: Array<{                // References to create
    containerId,
    entityType,
    entityId,
    isPrimary
  }>;
}
```

**Usage:**
```typescript
const plan = planGhostMaterialisation(
  workspaceId,
  guardrailsEntities,
  existingContainers,
  existingReferences
);

// Apply plan (services layer)
for (const input of plan.toCreate) {
  await createContainer(input);
}
```

---

#### `createGhostContainerForEntity()`

Creates a single ghost container for a Guardrails entity.

**Input:**
- `workspaceId` - Target workspace
- `entity` - Guardrails entity
- `hasBrokenLayout` - Whether workspace layout is broken

**Output:** `CreateMindMeshContainerInput`

**Behavior:**
- If layout intact: Positioned at default (will be laid out hierarchically)
- If layout broken: Positioned at origin (0, 0) as free-floating

---

#### `syncGhostContainerMetadata()`

Syncs ghost container metadata with Guardrails entity.

**Input:**
- `container` - Current ghost container
- `entity` - Authoritative Guardrails entity

**Output:** `Partial<MindMeshContainer>` or `null` (if no changes)

**Syncs:**
- Title
- Body (description)
- Metadata

**Does NOT sync:**
- Position (`xPosition`, `yPosition`)
- Nesting (`parentContainerId`)
- Dimensions (`width`, `height`)

**Why:** Position and nesting are local Mind Mesh concerns, not Guardrails authority.

---

### Layout Computation

#### `computeDefaultHierarchyLayout()`

Computes default spatial positions based on Guardrails hierarchy.

**Input:**
- `entities` - All Guardrails entities
- `existingContainers` - Current containers
- `existingReferences` - References mapping entities to containers

**Output:**
```typescript
LayoutPosition[] = Array<{
  containerId: string;
  xPosition: number;
  yPosition: number;
  parentContainerId: string | null;
}>
```

**Algorithm:**
1. Separate entities by type (tracks, subtracks, items)
2. Sort by `orderIndex` or ID (deterministic)
3. Position tracks horizontally
4. Position subtracks/items vertically under parents with indentation
5. Return position assignments

**Characteristics:**
- Deterministic (same input = same output)
- Idempotent (safe to re-run)
- No side effects (pure function)

---

#### `planAutoGeneratedHierarchyNodes()`

Plans creation of auto-generated nodes representing composition hierarchy.

**Input:**
- `workspaceId` - Target workspace
- `positions` - Layout positions (includes parent-child info)
- `existingPorts` - Current ports
- `existingContainers` - Current containers

**Output:**
```typescript
{
  toCreatePorts: CreateMindMeshPortInput[];
  toCreateNodes: CreateMindMeshNodeInput[];
}
```

**Behavior:**
- Creates output port for each parent container
- Creates input port for each child container
- Creates node connecting parent output → child input
- All nodes have `isAutoGenerated = true`

---

#### `validateLayoutPositions()`

Validates that layout positions won't create cycles.

**Input:**
- `positions` - Proposed layout positions
- `existingContainers` - Current containers

**Output:**
```typescript
{
  valid: boolean;
  errors: string[];
}
```

**Checks:**
- No cycles in nesting hierarchy
- All parent IDs are valid
- No container is its own parent

---

### Layout Break Detection

#### `isLayoutBreakingEvent()`

Determines if an event breaks default layout.

**Input:**
- `event` - Type of event
- `context` - Optional context (previous/new values)

**Output:** `boolean`

**Breaking Events:**
- `manual_container_move` - Position changed
- `manual_container_nesting` - Parent changed
- `container_activated` - Ghost became active
- `auto_node_hidden` - Hierarchy visualization rejected
- `manual_layout_change` - Explicit positioning

**Usage:**
```typescript
if (isLayoutBreakingEvent('manual_container_move', {
  previousPosition: { x: 100, y: 100 },
  newPosition: { x: 250, y: 150 }
})) {
  markDefaultLayoutBroken(workspace);
}
```

---

#### `markDefaultLayoutBroken()`

Marks workspace layout as broken (one-way operation).

**Input:** `workspace` - Current workspace

**Output:** `Partial<MindMeshWorkspace>` with `hasBrokenDefaultLayout = true`

**Effect:** Auto-layout backs off permanently until explicit reset.

---

#### `hasIntactDefaultLayout()`

Checks if workspace has intact default layout.

**Input:** `workspace`

**Output:** `boolean`

**Returns:**
- `true` - Auto-layout may apply (but only if first time or after reset)
- `false` - Auto-layout must NOT apply (backing off)

---

### Spawn Strategy

#### `getGhostSpawnStrategy()`

Determines how new ghost containers should spawn.

**Input:** `hasBrokenLayout` - Whether layout is broken

**Output:**
```typescript
{
  autoPosition: boolean;      // Should auto-compute position?
  autoNest: boolean;           // Should auto-nest under parent?
  autoGenerateNodes: boolean;  // Should create hierarchy nodes?
  defaultPosition: { x, y };   // Default spawn location
}
```

**When Layout Intact:**
```typescript
{
  autoPosition: true,
  autoNest: true,
  autoGenerateNodes: true,
  defaultPosition: { x: 100, y: 100 }
}
```

**When Layout Broken:**
```typescript
{
  autoPosition: false,
  autoNest: false,
  autoGenerateNodes: false,
  defaultPosition: { x: 0, y: 0 }  // Origin, user must move
}
```

---

#### `shouldApplyAutoLayout()`

Determines if auto-layout should apply to workspace.

**Input:**
- `workspace` - Target workspace
- `isFirstMaterialisation` - Whether this is initial setup

**Output:** `boolean`

**Logic:**
```
if (workspace.hasBrokenDefaultLayout) return false;  // Never if broken
if (isFirstMaterialisation) return true;             // Apply on first time
return false;                                         // Otherwise don't apply
```

**Note:** After explicit reset, `hasBrokenDefaultLayout = false`, but `isFirstMaterialisation = false`. So auto-layout doesn't reapply automatically—only the reset itself applies layout.

---

### Reset Functions

#### `planResetToDefaultLayout()`

Plans a complete reset to default hierarchy layout.

**Input:**
- `workspaceId` - Target workspace
- `entities` - Current Guardrails entities
- `existingContainers` - Current containers
- `existingReferences` - Current references
- `existingPorts` - Current ports

**Output:**
```typescript
{
  workspaceUpdate: Partial<MindMeshWorkspace>;  // Clear broken flag
  containerUpdates: Array<{                      // Reposition all
    containerId,
    updates: { xPosition, yPosition, parentContainerId }
  }>;
  autoNodesToDelete: string[];                   // Old auto-nodes
  toCreatePorts: CreateMindMeshPortInput[];      // New ports
  toCreateNodes: CreateMindMeshNodeInput[];      // New auto-nodes
  errors: string[];
}
```

**Behavior:**
1. Recompute hierarchy positions
2. Apply to all containers (ghost and user-created)
3. Delete old auto-generated nodes
4. Create new auto-generated nodes
5. Clear `hasBrokenDefaultLayout` flag
6. Record `lastLayoutResetAt` timestamp

**Constraints:**
- Never deletes containers
- Respects validation invariants
- User must invoke explicitly

---

#### `planIncrementalLayoutUpdate()`

Plans incremental layout for newly added entities.

**Input:**
- `workspaceId` - Target workspace
- `newEntities` - Newly added Guardrails entities
- `existingContainers` - Current containers
- `existingReferences` - Current references

**Output:**
```typescript
{
  containerUpdates: Array<{ containerId, updates }>;
  errors: string[];
}
```

**Behavior:**
- Only positions new containers
- Existing containers are NOT repositioned (preserves user changes)
- Positions new containers relative to parent (if found)
- Fallback to default spawn position

---

#### `planClearManualPositioning()`

Plans clearing of manual positions while preserving nesting.

**Input:**
- `workspaceId` - Target workspace
- `entities` - Current Guardrails entities
- `existingContainers` - Current containers
- `existingReferences` - Current references

**Output:**
```typescript
{
  containerUpdates: Array<{ containerId, updates }>;
  errors: string[];
}
```

**Behavior:**
- Resets `xPosition` and `yPosition` to default
- Preserves `parentContainerId` (keeps nesting structure)
- Useful for "clean up visual mess" without restructuring

---

## Layout Constants

Defined in `DEFAULT_LAYOUT`:

```typescript
{
  TRACK_SPACING_X: 400,      // Horizontal space between tracks
  TRACK_SPACING_Y: 600,      // Vertical space for track lane
  SUBTRACK_OFFSET_X: 50,     // Indent for subtracks
  SUBTRACK_SPACING_Y: 300,   // Vertical space between subtracks
  ITEM_OFFSET_X: 50,         // Indent for roadmap items
  ITEM_SPACING_Y: 150,       // Vertical space between items
  SUBITEM_OFFSET_X: 40,      // Indent for sub-items
  SUBITEM_SPACING_Y: 120,    // Vertical space between sub-items
  INITIAL_X: 100,            // Starting X coordinate
  INITIAL_Y: 100,            // Starting Y coordinate
  DEFAULT_WIDTH: 240,        // Default container width
  DEFAULT_HEIGHT: 160,       // Default container height
}
```

**Note:** These are abstract units, not pixels. UI layer can scale/transform as needed.

---

## Helper Utilities

### `hasManualPosition()`

Checks if container has been manually moved from default.

---

### `hasManualNesting()`

Checks if container has been manually nested (different parent).

---

### `computeBoundingBox()`

Computes bounding box for a set of containers. Useful for "zoom to fit".

---

### `detectLayoutIssues()`

Detects layout problems:
- Containers out of bounds (negative positions)
- Overlapping containers

---

## Invariants

### I1. Ghosts Represent Existence, Not Attention

Ghost containers show what exists in Guardrails, not what the user is focused on. They are passive, not active.

---

### I2. Default Layout Applies Once

Default layout applies on first materialization, then never again (unless explicit reset).

---

### I3. Backing Off is Permanent

Once `hasBrokenDefaultLayout = true`, it stays `true` until explicit user reset. No automatic recovery.

---

### I4. No Fighting the User

System never repositions containers after user has moved them. User intent is respected.

---

### I5. Guardrails Authority is Sacred

Layout logic never mutates Guardrails entities. Ghost deletion never deletes Guardrails data.

---

### I6. Layout is Pure Logic

Layout functions are pure (no side effects). They plan operations but don't execute them.

---

### I7. No UI Assumptions

Layout logic uses abstract units, not pixels. No drag handlers, click handlers, or rendering logic.

---

## Decision Tree: Should Auto-Layout Apply?

```
┌─ Is this first materialization?
│  ├─ YES → Apply default layout
│  └─ NO → ┐
│          ├─ Is hasBrokenDefaultLayout = false?
│          │  ├─ YES → Do NOT apply (unless explicit reset)
│          │  └─ NO → Do NOT apply (backing off)
│          └─ Was explicit reset just invoked?
│             ├─ YES → Apply layout (part of reset)
│             └─ NO → Do NOT apply
```

---

## Decision Tree: How to Spawn New Ghost?

```
┌─ Is hasBrokenDefaultLayout = true?
│  ├─ YES → Spawn at origin (0, 0), no auto-nest, no auto-nodes
│  └─ NO → ┐
│          ├─ Is this first materialization?
│          │  ├─ YES → Compute position from hierarchy, auto-nest, auto-nodes
│          │  └─ NO → Spawn at default position, no auto-nest, no auto-nodes
```

---

## Testing Scenarios

### Test 1: First Materialization

```typescript
const workspace = { hasBrokenDefaultLayout: false };
const entities = [trackA, trackB, subtrackC];
const isFirst = true;

expect(shouldApplyAutoLayout(workspace, isFirst)).toBe(true);

const positions = computeDefaultHierarchyLayout(entities, [], []);
expect(positions).toHaveLength(3);
expect(positions[0].parentContainerId).toBe(null); // Track A is root
expect(positions[2].parentContainerId).toBe(trackA.id); // Subtrack C under Track A
```

---

### Test 2: Layout Break Detection

```typescript
const event = 'manual_container_move';
const context = {
  previousPosition: { x: 100, y: 100 },
  newPosition: { x: 250, y: 150 }
};

expect(isLayoutBreakingEvent(event, context)).toBe(true);
```

---

### Test 3: Spawn Strategy After Break

```typescript
const hasBroken = true;
const strategy = getGhostSpawnStrategy(hasBroken);

expect(strategy.autoPosition).toBe(false);
expect(strategy.autoNest).toBe(false);
expect(strategy.autoGenerateNodes).toBe(false);
expect(strategy.defaultPosition).toEqual({ x: 0, y: 0 });
```

---

### Test 4: Reset Clears Flag

```typescript
const workspace = { hasBrokenDefaultLayout: true };
const resetPlan = planResetToDefaultLayout(
  workspaceId,
  entities,
  containers,
  references,
  ports
);

expect(resetPlan.workspaceUpdate.hasBrokenDefaultLayout).toBe(false);
expect(resetPlan.workspaceUpdate.lastLayoutResetAt).toBeDefined();
```

---

## Summary

The Mind Mesh V2 layout system is a **respectful, self-aware** auto-layout engine that:

1. **Materializes** Guardrails entities as ghost containers
2. **Positions** them hierarchically on first load
3. **Detects** when user takes control
4. **Backs off** permanently once user demonstrates intent
5. **Respects** user positioning and nesting choices
6. **Resets** only when explicitly requested
7. **Never fights** the user or makes assumptions

**Core Philosophy:** The system helps until it's clear the user wants control, then it gets out of the way.

---

**Status:** Layout system complete, ready for service integration
**Next Step:** Implement services that use these layout planners
