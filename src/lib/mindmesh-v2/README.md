# Mind Mesh V2 Core Data Model

## Overview

Mind Mesh V2 is a visual cognition system inspired by ComfyUI-style graph systems. It separates **containers** (which hold meaning) from **nodes** (which represent relationships), creating a flexible knowledge graph tightly integrated with Guardrails project management.

**Status:** Core data model implemented. No UI, services, or business logic yet.

## Core Principles

1. **Containers Hold Meaning** - Containers are boxes with content (title/body)
2. **Nodes Hold Relationships** - Nodes connect ports, they have no semantic content
3. **Guardrails is Authoritative** - Tracks, items, people remain the source of truth
4. **Ports are Connection Points** - Nodes connect ports, not containers directly
5. **Multi-Reference Support** - Containers can reference multiple Guardrails entities

## Data Model

### Workspace

One workspace per project. Contains all containers, nodes, and ports.

```typescript
interface MindMeshWorkspace {
  id: string;
  masterProjectId: string;
  metadata: Record<string, any>;
}
```

**Constraint:** One workspace per project (unique)

### Container (Holds Meaning)

Containers are boxes with content. They can be nested and reference Guardrails entities.

```typescript
interface MindMeshContainer {
  id: string;
  workspaceId: string;

  // Content (must have at least one)
  title: string | null;
  body: string | null;

  // Nesting
  parentContainerId: string | null;

  // Ghost state (read-only)
  isGhost: boolean;

  // Visual properties
  xPosition: number;
  yPosition: number;
  width: number;
  height: number;

  metadata: Record<string, any>;
}
```

**Key Rules:**
- Must have `title` OR `body` (at least one)
- Ghost containers are read-only representations
- Can be nested via `parentContainerId`
- Visual properties stored (not computed)

### Container Reference (Links to Guardrails)

Explicit references from containers to Guardrails entities.

```typescript
interface MindMeshContainerReference {
  id: string;
  containerId: string;
  entityType: GuardrailsEntityType;
  entityId: string;
  isPrimary: boolean;
  metadata: Record<string, any>;
}
```

**Supported Entity Types:**
- `track`
- `roadmap_item`
- `person`
- `widget`
- `domain`
- `project`

**Key Rules:**
- Multiple references per container allowed
- Exactly one primary reference if any exist (enforced by trigger)
- One reference per entity per container (unique constraint)

### Port (Connection Point)

Ports are connection points on containers where nodes attach.

```typescript
interface MindMeshPort {
  id: string;
  containerId: string;
  portType: 'free' | 'input' | 'output';
  label: string | null;
  metadata: Record<string, any>;
}
```

**Port Types:**
- `free` - No type constraint
- `input` - Input port
- `output` - Output port

### Node (Relationship Only)

Nodes represent relationships between containers. They connect ports, not containers.

```typescript
interface MindMeshNode {
  id: string;
  workspaceId: string;

  // Connection (two ports)
  sourcePortId: string;
  targetPortId: string;

  // Relationship semantics
  relationshipType: RelationshipType;
  relationshipDirection: 'forward' | 'backward' | 'bidirectional';

  // Auto-generated flag
  autoGenerated: boolean;

  metadata: Record<string, any>;
}
```

**Relationship Types:**
- `expands`
- `inspires`
- `depends_on`
- `references`
- `hierarchy`
- `composition`
- `generic`

**Key Rules:**
- Nodes connect ports, not containers directly
- Source and target must be different (constraint)
- Multiple nodes between same containers allowed
- Auto-deletes if ports are deleted (CASCADE)

### Container Visibility (Per-User)

Per-user visibility settings for containers.

```typescript
interface MindMeshContainerVisibility {
  id: string;
  containerId: string;
  userId: string;
  visibilityState: 'visible' | 'hidden' | 'collapsed';
}
```

**Purpose:** Allows users to hide/collapse containers without affecting others

### Canvas Lock (Workspace-Level)

Workspace-level edit lock. One user at a time.

```typescript
interface MindMeshCanvasLock {
  id: string;
  workspaceId: string;
  userId: string;
  expiresAt: string;
}
```

**Purpose:** Prevents concurrent editing conflicts

## Database Tables

1. **mindmesh_workspaces** - One per project
2. **mindmesh_containers** - Holds meaning/content
3. **mindmesh_container_references** - Links to Guardrails
4. **mindmesh_ports** - Connection points
5. **mindmesh_nodes** - Relationships only
6. **mindmesh_container_visibility** - Per-user visibility
7. **mindmesh_canvas_locks** - Edit locking

## Key Constraints

### Database Constraints

1. **Container Content:** Must have `title` OR `body`
2. **Workspace Uniqueness:** One workspace per project
3. **Reference Uniqueness:** One reference per entity per container
4. **User Visibility Uniqueness:** One visibility setting per user per container
5. **Workspace Lock Uniqueness:** One lock per workspace
6. **Node Port Difference:** Source and target ports must be different

### Trigger-Enforced Rules

1. **Single Primary Reference:** Only one `isPrimary = true` per container
2. **Updated At:** Auto-updates timestamps on changes

### Cascade Behaviors

1. **Workspace Deleted:** All containers, nodes, ports deleted (CASCADE)
2. **Container Deleted:** All ports, references, visibility settings deleted (CASCADE)
3. **Port Deleted:** All nodes referencing that port deleted (CASCADE)
4. **Parent Container Deleted:** Child containers have `parentContainerId` set to null (SET NULL)

## Row Level Security (RLS)

All tables have RLS policies based on project ownership:

- **Workspaces:** Users can access workspaces for their projects
- **Containers:** Users can access containers in their workspaces
- **References:** Inherit permissions from container
- **Ports:** Inherit permissions from container
- **Nodes:** Users can access nodes in their workspaces
- **Visibility:** Users can only manage their own visibility settings
- **Locks:** Users can create locks for their workspaces, delete their own locks

## Validation & Invariants (IMPLEMENTED)

**Status:** ✅ Complete

A comprehensive validation layer enforces all architectural invariants:

- **validation.ts** - Pure validation functions with explicit error returns
- **INVARIANTS.md** - Complete documentation of all invariants

### Validation Functions

- `validateContainerInput()` - Check content requirement, dimensions
- `validateContainerContentUpdate()` - Ensure updates maintain content
- `validateContainerNesting()` - Detect cycles in parent-child hierarchy
- `validateGhostContainerImmutability()` - Block ghost container edits
- `validateContainerReferences()` - Check uniqueness, primary logic
- `validatePrimaryReferenceUpdate()` - Maintain single primary reference
- `validateReferenceDeletion()` - Ensure new primary when deleting primary
- `validatePortCreation()` - Check container exists, valid port type
- `validateNodeCreation()` - Check ports exist, same workspace, not self-connection
- `validateNodeHasNoContent()` - Block semantic content in nodes
- `validateLockAcquisition()` - Check single lock, valid duration
- `validateWritePermission()` - Ensure lock holder before writes

### Helper Utilities

- `buildContainerHierarchy()` - Create parent-child map
- `getContainerAncestors()` - Compute ancestor chain
- `getContainerDescendants()` - Compute descendant tree
- `detectOrphanedChildren()` - Warn about children that will be orphaned
- `detectCascadeDeletion()` - Warn about cascade deletion scope
- `isLockExpired()` - Check lock expiry
- `isLockHolder()` - Check if user holds lock
- Type guards: `hasContent()`, `isGhostContainer()`, `isPrimaryReference()`

### Key Invariants Enforced

1. **Containers** - Must have title OR body, no cycles, ghost immutability
2. **References** - No duplicates, exactly one primary, non-authoritative
3. **Ports** - Must belong to container, workspace consistency
4. **Nodes** - Connect valid ports, same workspace, no self-connections, no semantic content
5. **Locks** - Single lock per workspace, expiry enforcement, write permission

See `INVARIANTS.md` and `VALIDATION_GUIDE.md` for complete documentation.

---

## Auto-Layout & Ghost Logic (IMPLEMENTED)

**Status:** ✅ Complete

Deterministic system logic for materializing Guardrails entities and applying hierarchy-based layout:

- **layout.ts** - Ghost materialisation, layout computation, backing-off logic
- **LAYOUT_SYSTEM.md** - Complete documentation of layout behavior

### Layout System Overview

The layout system is a **self-backing-off** auto-layout engine that:

1. **Materializes** Guardrails entities as ghost containers (`isGhost = true`)
2. **Applies** default hierarchy-based positioning on first load
3. **Detects** when user takes control (moves containers, changes nesting)
4. **Backs off** permanently once user demonstrates intent
5. **Respects** user choices until explicit reset

### Key Features

#### Ghost Materialisation
- `planGhostMaterialisation()` - Create ghost containers for Guardrails entities
- `createGhostContainerForEntity()` - Materialize single entity
- `syncGhostContainerMetadata()` - Keep ghosts in sync with Guardrails

#### Layout Computation
- `computeDefaultHierarchyLayout()` - Calculate positions from Guardrails hierarchy
- `planAutoGeneratedHierarchyNodes()` - Create nodes showing composition structure
- `validateLayoutPositions()` - Ensure no cycles in nesting

#### Layout Break Detection
- `isLayoutBreakingEvent()` - Detect when user takes control
- `markDefaultLayoutBroken()` - Set one-way flag (permanent until reset)
- `getGhostSpawnStrategy()` - Determine behavior based on layout state

#### Reset Functions (User-Invoked Only)
- `planResetToDefaultLayout()` - Full reset to hierarchy layout
- `planIncrementalLayoutUpdate()` - Position new entities only
- `planClearManualPositioning()` - Reset positions, preserve nesting

### Core Behavior

**When Layout Intact:**
- New entities positioned hierarchically
- Auto-nesting under parents
- Auto-generated hierarchy nodes created

**When Layout Broken:**
- New entities spawn at origin (0, 0)
- No auto-nesting
- No auto-generated nodes
- User has full control

See `LAYOUT_SYSTEM.md` for complete documentation.

---

## Canvas Interaction Logic (IMPLEMENTED)

**Status:** ✅ Complete

Logic-only interaction layer that translates user actions into state transitions:

- **interactions.ts** - Activation, movement, nesting, node operations, lock enforcement
- **INTERACTION_LOGIC.md** - Complete documentation of interaction behavior

### Interaction System Overview

The interaction system is a **deterministic, explicit, permission-aware** domain controller that:

1. **Detects explicit user intent** - No inference or guessing
2. **Plans state transitions** - Never executes, only plans
3. **Enforces permissions** - Canvas lock checked everywhere
4. **Activates ghosts safely** - Always explicit, tracked
5. **Respects user control** - Breaks layout when appropriate
6. **Emits events internally** - For future Regulation integration

### Key Features

#### Container Activation
- `canActivateContainer()` - Check if activation allowed
- `planContainerActivation()` - Plan ghost activation
- `getCascadeActivationTargets()` - Find children that would activate
- Activation reasons: `user_drag`, `user_connect_node`, `user_nest`, `user_explicit`

#### Movement & Resize
- `planContainerMove()` - Plan position update
- `planContainerResize()` - Plan dimension update
- Activates ghosts when involved
- Breaks layout when manual

#### Nesting Operations
- `planContainerNesting()` - Plan nesting under parent
- `planContainerUnnesting()` - Plan restoration to root
- Validates no cycles
- Activates ghosts in both parent and child

#### Node Operations (Manual)
- `planManualNodeCreation()` - Plan node creation
- `planNodeDeletion()` - Plan node deletion (manual only)
- `wouldHidingNodeBreakLayout()` - Check layout impact
- Auto-generated nodes cannot be deleted, only hidden

#### Canvas Lock Enforcement
- `planCanvasLockAcquisition()` - Plan lock acquisition
- `planCanvasLockRelease()` - Plan lock release
- `assertCanvasWriteAllowed()` - Check write permission
- `shouldAutoReleaseLock()` - Check expiry
- All write operations require lock

#### Interaction Events (Internal)
- `InteractionEvent` types (9 event types)
- `InteractionEventEmitter` class
- In-memory events (not persisted yet)
- For future Regulation integration

### Core Behavior

**Activation is Always Explicit:**
- User drags ghost → activate
- User connects node to ghost → activate
- User nests into ghost → activate
- User clicks "Activate" → activate
- Never automatic or inferred

**User Actions Override Auto-Layout:**
- Manual move → breaks layout permanently
- Manual nest → breaks layout permanently
- Container activation → breaks layout permanently
- Once broken, stays broken until explicit reset

**Canvas Lock is Enforced:**
- All write operations check lock
- Lock holder validated
- Expired locks rejected

See `INTERACTION_LOGIC.md` for complete documentation.

---

## Execution Service (IMPLEMENTED)

**Status:** ✅ Complete

Atomic plan execution with proper locking and rollback support:

- **execution.ts** - Execution service with transaction boundaries

### Execution Service Overview

The execution service is the **obedient executor** that:

1. **Executes plans atomically** - All mutations in single transaction
2. **Enforces canvas locks** - No writes without active lock
3. **Re-checks preconditions** - Plans may be stale
4. **Applies mutations in order** - Sequential execution
5. **Emits events on success** - Only after commit
6. **Persists telemetry** - After successful commit
7. **Stores execution history** - For bounded rollback
8. **Never infers intent** - Obeys plan exactly

### Key Features

#### Execution Pipeline (Non-Negotiable Order)
1. Assert canvas lock held by user
2. Open database transaction (implicit)
3. Re-check plan preconditions
4. Apply plan mutations in order
5. Emit interaction events (on commit only)
6. Persist telemetry (after commit)
7. Store plan in execution history
8. Release lock

If any step fails → abort transaction, return error, no events/telemetry emitted.

#### Mutation Types (7 total)
- `create_container` - Create new container
- `update_container` - Update container fields
- `delete_container` - Delete container
- `create_node` - Create new node (connection)
- `update_node` - Update node fields
- `delete_node` - Delete node
- `update_workspace_flags` - Update workspace flags (e.g., hasBrokenDefaultLayout)

#### Plan Repairs (MVP-Safe, Limited)
Services may apply minimal repairs:
- Adding timestamps (created_at, updated_at)
- Normalizing metadata shapes
- Ensuring required fields exist

Repairs are:
- **Explicit** - Logged in execution result
- **Non-semantic** - Never change meaning or structure
- **Non-overriding** - Never override user intent

#### Rollback Support (Bounded)
- Stores last 3 plans per workspace
- Each plan includes inverse mutations
- `rollbackLastPlan()` - Executes inverse mutations atomically
- Requires canvas lock
- Applies to Mind Mesh state only (never Guardrails)
- Best-effort (some operations cannot be perfectly reversed)

#### Concurrency & Locking
- Execution requires active canvas lock
- Lock held for full transaction duration
- No concurrent plan execution per workspace
- Lock release guaranteed on success or failure

#### Telemetry Integration
- Uses existing telemetry emitter
- Emits telemetry only after successful commit
- Never emits telemetry on rollback failure
- Privacy contract enforced (no content or IDs)

### Core Behavior

**Execution Contract:**
- Executes exactly what the plan says
- Never infers missing steps
- Never "helps" or suggests
- Never modifies plan intent
- All mutations atomic
- No partial commits ever
- Guardrails never mutated

**Error Handling:**
- Any mutation failure → entire plan fails
- Transaction rolled back automatically
- Explicit error messages returned
- No events or telemetry emitted on failure

**Determinism:**
- Same plan + same state → same result
- No randomness or inference
- Testable and predictable
- Pure obedience

---

## Regulation Telemetry Layer (IMPLEMENTED)

**Status:** ✅ Complete

Privacy-preserving telemetry pipeline for Regulation integration:

- **telemetry/types.ts** - Telemetry event types, allowed metadata, validation
- **telemetry/mapper.ts** - Privacy firewall that strips forbidden fields
- **telemetry/emitter.ts** - Persistence layer with batch operations
- **telemetry/aggregations.ts** - Descriptive metrics (no scoring)
- **telemetry/TELEMETRY_CONTRACT.md** - Complete privacy contract documentation

### Telemetry System Overview

The telemetry system is a **privacy firewall** that:

1. **Captures structural patterns** - NOT content or meaning
2. **Strips forbidden fields** - NO titles, IDs, or references
3. **Validates all events** - Privacy contract enforced
4. **Provides descriptive metrics** - NO scoring or judgments
5. **Persists to database** - With RLS and indexes

### Key Features

#### Privacy Contract
- **Forbidden**: content (title, body), IDs (container, node, reference), positions, dimensions
- **Allowed**: event types, timestamps, categorical metadata, boolean flags, aggregate counts
- Prime Rule: Mind Mesh emits behaviour. Regulation interprets patterns. Regulation never interprets meaning.

#### Event Types (23 total)
- Container events (10): Created, Activated, Moved, Resized, Nested, Unnested, Converted, Hidden, Collapsed, Deleted
- Node events (5): Created, Deleted, TypeChanged, DirectionChanged, Hidden
- Layout events (4): DefaultLayoutBroken, DefaultLayoutReset, FocusModeEntered, FocusModeExited
- Session events (4): CanvasLockAcquired, CanvasLockReleased, WorkspaceOpened, WorkspaceClosed

#### Privacy Firewall (Mapper)
- `mapInteractionEventToTelemetry()` - Strip forbidden fields
- `batchMapInteractionEvents()` - Batch mapping
- `createManualTelemetryEvent()` - Session tracking
- `assertNoForbiddenFields()` - Privacy validation
- `assertCannotReconstructGraph()` - Structural validation

#### Emitter (Persistence)
- `emitTelemetryEvent()` - Single event persistence
- `emitFromInteractionEvent()` - Auto-mapping + persistence
- `batchEmitFromInteractionEvents()` - Batch persistence
- `createTelemetryListener()` - Auto-listener for interaction events
- `createBatchTelemetryListener()` - Batched listener for high volume

#### Aggregations (Descriptive Only)
- `getDailyActivitySummary()` - Event counts, session duration, activity level
- `getWeeklyPatternSummary()` - Daily distribution, creation bursts, layout breaks
- `getEventCountsByType()` - Type distribution
- `getTotalEventCount()` - Activity level
- `getUsageTimespan()` - First/last event timestamps

All aggregations are **descriptive only** - no scoring, no judgments, no recommendations.

### Database Schema

**Table:** `mind_mesh_telemetry_events`
- Columns: `id`, `workspace_id`, `user_id`, `event_type`, `timestamp`, `meta`, `created_at`
- Indexes: workspace+timestamp, user+timestamp, event_type+timestamp, timestamp
- RLS: Users can insert/read own telemetry

### Core Behavior

**Privacy Firewall:**
```
Interaction Event → Mapper (strip IDs) → Telemetry Event → Validator → Database
```

**What is Captured:**
- ✅ Event type (categorical)
- ✅ Timestamp (temporal)
- ✅ Flags (isGhost, isAutoGenerated)
- ✅ Categorical metadata (activationReason, relationshipType)
- ✅ Aggregate counts (sessionMinutes, entityCount)

**What is NOT Captured:**
- ❌ Container title/body (content)
- ❌ Container IDs (structure)
- ❌ Reference IDs (meaning)
- ❌ Positions/dimensions (layout)
- ❌ Node endpoints (relationships)

See `telemetry/TELEMETRY_CONTRACT.md` for complete privacy contract.

---

## What is NOT Implemented

### No UI
- No canvas rendering
- No drag-and-drop
- No visual editing
- No node positioning UI
- No port visualization

### No Higher-Level Services
- No ghost materialisation service (layout planners ready, execution ready)
- No plan creation services (interaction planners ready, execution ready)
- No business rules beyond validation, layout, interaction, telemetry, and execution
- Execution service ready, needs integration with plan generators

### No Regulation UI
- No Regulation Hub UI
- No scoring or judgment systems
- No recommendations or prompts
- Telemetry aggregations ready for Regulation consumption

### No AI Features
- No auto-suggestions
- No semantic analysis
- No graph optimization

## Sanity Check Results

Before finishing, verified:

✅ **Containers hold meaning** - title/body fields, content constraint
✅ **Nodes hold relationships only** - no content fields, only port connections
✅ **Guardrails authority untouched** - references are non-authoritative links
✅ **No UI assumptions** - purely data structures, no rendering logic
✅ **Ports are connection points** - nodes connect ports, not containers
✅ **Multi-reference support** - containers can reference multiple entities
✅ **Ghost state supported** - read-only containers via `isGhost` flag
✅ **Nesting supported** - unlimited depth via `parentContainerId`
✅ **Per-user visibility** - visibility settings are user-specific
✅ **Edit locking** - workspace-level locks prevent conflicts

## Next Steps

To use this data model, you'll need to implement:

1. **Services** - CRUD operations for all entities (validation and layout planners ready)
2. **Ghost Materialisation Service** - Use layout.ts planners to create ghosts from Guardrails
3. **Canvas UI** - Visual rendering and interaction
4. **Layout Application Service** - Execute layout plans from layout.ts
5. **Regulation Integration** - Connect to existing regulation system

## Example Usage (Future)

```typescript
// Create workspace
const workspace = await createWorkspace({
  masterProjectId: 'project-123'
});

// Create container
const container = await createContainer({
  workspaceId: workspace.id,
  title: 'MVP Planning',
  body: 'Core features for launch',
  xPosition: 100,
  yPosition: 100
});

// Link to Guardrails track
await createContainerReference({
  containerId: container.id,
  entityType: 'track',
  entityId: 'track-456',
  isPrimary: true
});

// Create ports
const port1 = await createPort({
  containerId: container.id,
  portType: 'output',
  label: 'Next Steps'
});

const port2 = await createPort({
  containerId: anotherContainer.id,
  portType: 'input',
  label: 'Prerequisites'
});

// Connect with node
await createNode({
  workspaceId: workspace.id,
  sourcePortId: port1.id,
  targetPortId: port2.id,
  relationshipType: 'depends_on',
  relationshipDirection: 'forward'
});
```

## Files

### Core Implementation
- **types.ts** - TypeScript type definitions
- **validation.ts** - Domain validation logic and invariant enforcement
- **layout.ts** - Ghost materialisation and auto-layout logic
- **interactions.ts** - Canvas interaction logic and state transition planning
- **execution.ts** - Atomic plan execution with locking and rollback
- **telemetry/types.ts** - Telemetry event types and privacy contract
- **telemetry/mapper.ts** - Privacy firewall (strips forbidden fields)
- **telemetry/emitter.ts** - Persistence layer with batch operations
- **telemetry/aggregations.ts** - Descriptive metrics (no scoring)
- **telemetry/index.ts** - Telemetry module exports

### Documentation
- **README.md** - This file (architecture overview)
- **INVARIANTS.md** - Complete documentation of architectural invariants
- **VALIDATION_GUIDE.md** - Practical usage guide for validation
- **LAYOUT_SYSTEM.md** - Complete documentation of layout behavior
- **INTERACTION_LOGIC.md** - Complete documentation of interaction behavior
- **telemetry/TELEMETRY_CONTRACT.md** - Complete privacy contract documentation

### Database
- **Migration: 20251217093022_20251217000000_create_mindmesh_v2_core.sql** - Core schema
- **Migration: 20251217094138_add_mindmesh_layout_tracking.sql** - Layout tracking fields
- **Migration: create_mindmesh_telemetry.sql** - Telemetry events table

---

**Document Status:** Core data model, validation, layout logic, interaction logic, telemetry layer, and execution service complete
**Last Updated:** December 2025
