import type {
  AIIntent,
  AIResponseType,
  AIContextScope,
  AIResponse,
  AIExplanation,
  AISuggestion,
  AICritique,
  DraftRoadmapItemContent,
  DraftTaskListContent,
  DraftSummaryContent,
  DraftChecklistContent,
  DraftTimelineContent,
  DraftRiskAnalysisContent,
  AIProvenanceMetadata,
  RecordAIInteractionInput,
  AIInteractionAudit,
} from './aiTypes';
import { buildContext, buildContextForProject, buildContextForTrack, buildContextForRoadmapItem } from './aiContextAssembly';
import { createDraft } from './aiDraftService';
import { supabase } from '../../supabase';
import { conversationService } from './conversationService';
import { createTextMessage, type MessageContent } from './aiChatTypes';

export async function generateDraftRoadmapItem(
  userId: string,
  projectId: string,
  trackId: string,
  userPrompt: string
): Promise<{
  success: boolean;
  draftId?: string;
  content?: DraftRoadmapItemContent;
  error?: string;
}> {
  const context = await buildContextForTrack(trackId, userId);

  const draftContent: DraftRoadmapItemContent = {
    title: `[AI Draft] ${userPrompt.substring(0, 50)}`,
    description: 'This is a draft roadmap item generated by AI. Review and edit before accepting.',
    estimatedDuration: 5,
    suggestedTrackId: trackId,
    reasoning: `Generated based on track context: ${context.tracks?.[0]?.name || 'Unknown'}. User requested: "${userPrompt}"`,
  };

  const provenance: AIProvenanceMetadata = {
    sourceEntityIds: [trackId, ...(context.roadmapItems?.map(i => i.id) || [])],
    sourceEntityTypes: ['track', ...Array(context.roadmapItems?.length || 0).fill('roadmap_item')],
    contextSnapshot: { trackName: context.tracks?.[0]?.name },
    generatedAt: new Date().toISOString(),
    confidenceLevel: 'medium',
  };

  const result = await createDraft({
    userId,
    projectId,
    draftType: 'roadmap_item',
    title: draftContent.title,
    content: draftContent,
    provenanceMetadata: provenance,
    contextScope: context.scope,
  });

  if (!result.success || !result.draft) {
    return { success: false, error: result.error };
  }

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'draft_roadmap_item',
    responseType: 'draft',
    contextScope: context.scope,
    entitiesIncluded: { trackId, itemCount: context.roadmapItems?.length || 0 },
    draftId: result.draft.id,
    userPrompt,
  });

  return {
    success: true,
    draftId: result.draft.id,
    content: draftContent,
  };
}

export async function generateDraftTaskList(
  userId: string,
  projectId: string,
  roadmapItemId: string,
  userPrompt: string
): Promise<{
  success: boolean;
  draftId?: string;
  content?: DraftTaskListContent;
  error?: string;
}> {
  const context = await buildContextForRoadmapItem(roadmapItemId, userId);

  const item = context.roadmapItems?.[0];

  const draftContent: DraftTaskListContent = {
    tasks: [
      {
        title: `Task 1 for: ${item?.title || 'Unknown item'}`,
        description: 'Placeholder task generated by AI',
        estimatedDuration: 2,
        priority: 'medium',
      },
      {
        title: `Task 2 for: ${item?.title || 'Unknown item'}`,
        description: 'Another placeholder task',
        estimatedDuration: 3,
        priority: 'medium',
      },
    ],
    context: `Tasks for roadmap item: ${item?.title}`,
    reasoning: `Generated based on item context. User requested: "${userPrompt}"`,
  };

  const provenance: AIProvenanceMetadata = {
    sourceEntityIds: [roadmapItemId],
    sourceEntityTypes: ['roadmap_item'],
    contextSnapshot: { itemTitle: item?.title },
    generatedAt: new Date().toISOString(),
    confidenceLevel: 'medium',
  };

  const result = await createDraft({
    userId,
    projectId,
    draftType: 'task_list',
    title: `Task List for: ${item?.title || 'Item'}`,
    content: draftContent,
    provenanceMetadata: provenance,
    contextScope: context.scope,
  });

  if (!result.success || !result.draft) {
    return { success: false, error: result.error };
  }

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'draft_task_list',
    responseType: 'draft',
    contextScope: context.scope,
    entitiesIncluded: { roadmapItemId },
    draftId: result.draft.id,
    userPrompt,
  });

  return {
    success: true,
    draftId: result.draft.id,
    content: draftContent,
  };
}

export async function summariseProject(
  userId: string,
  projectId: string
): Promise<AIResponse> {
  const context = await buildContextForProject(projectId, userId);

  const summary: DraftSummaryContent = {
    summary: `Project: ${context.project?.name || 'Unknown'} has ${context.tracks?.length || 0} tracks with ${context.roadmapItems?.length || 0} roadmap items.`,
    keyPoints: [
      `${context.tracks?.length || 0} tracks organized`,
      `${context.roadmapItems?.length || 0} items planned`,
      `${context.deadlines?.length || 0} items with deadlines`,
      `${context.collaboration?.totalCollaborators || 0} collaborators active`,
    ],
    metrics: {
      trackCount: context.tracks?.length || 0,
      itemCount: context.roadmapItems?.length || 0,
      deadlineCount: context.deadlines?.length || 0,
      collaboratorCount: context.collaboration?.totalCollaborators || 0,
    },
    insights: [
      'This is a stub implementation. Real AI would analyze patterns and provide insights.',
    ],
  };

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'summarize',
    responseType: 'summary',
    contextScope: context.scope,
    entitiesIncluded: {
      projectId,
      trackCount: context.tracks?.length,
      itemCount: context.roadmapItems?.length,
    },
  });

  return {
    responseType: 'summary',
    data: summary,
    metadata: {
      intent: 'summarize',
      contextScope: context.scope,
      generatedAt: new Date().toISOString(),
    },
  };
}

export async function analyseDeadlines(
  userId: string,
  projectId: string
): Promise<AIResponse> {
  const context = await buildContextForProject(projectId, userId);

  const deadlines = context.deadlines || [];
  const overdueCount = deadlines.filter(d => d.isOverdue).length;
  const upcomingCount = deadlines.filter(d => !d.isOverdue && d.daysUntilDeadline <= 7).length;

  const summary: DraftSummaryContent = {
    summary: `Found ${deadlines.length} items with deadlines. ${overdueCount} overdue, ${upcomingCount} due within 7 days.`,
    keyPoints: [
      `${overdueCount} overdue items`,
      `${upcomingCount} items due in next 7 days`,
      `${deadlines.length - overdueCount - upcomingCount} items with future deadlines`,
    ],
    metrics: {
      total: deadlines.length,
      overdue: overdueCount,
      upcoming: upcomingCount,
    },
  };

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'analyze_deadlines',
    responseType: 'analysis',
    contextScope: context.scope,
    entitiesIncluded: {
      deadlineCount: deadlines.length,
      overdueCount,
      upcomingCount,
    },
  });

  return {
    responseType: 'analysis',
    data: summary,
    metadata: {
      intent: 'analyze_deadlines',
      contextScope: context.scope,
      generatedAt: new Date().toISOString(),
    },
  };
}

export async function explainRelationships(
  userId: string,
  projectId: string,
  entityId: string,
  entityType: string
): Promise<AIResponse> {
  const context = await buildContextForProject(projectId, userId);

  const explanation: AIExplanation = {
    subject: `Relationships for ${entityType}: ${entityId}`,
    explanation: `This ${entityType} is part of project ${context.project?.name}. (Stub implementation - real AI would analyze Mind Mesh connections, dependencies, and collaboration patterns.)`,
    context: {
      projectName: context.project?.name,
      mindMeshNodes: context.mindMesh?.nodeCount || 0,
      mindMeshEdges: context.mindMesh?.edgeCount || 0,
    },
    relatedEntities: [entityId],
  };

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'explain_relationships',
    responseType: 'explanation',
    contextScope: context.scope,
    entitiesIncluded: { entityId, entityType },
  });

  return {
    responseType: 'explanation',
    data: explanation,
    metadata: {
      intent: 'explain_relationships',
      contextScope: context.scope,
      generatedAt: new Date().toISOString(),
    },
  };
}

export async function suggestNextSteps(
  userId: string,
  projectId: string
): Promise<AIResponse> {
  const context = await buildContextForProject(projectId, userId);

  const suggestions: AISuggestion[] = [
    {
      title: 'Review overdue items',
      description: `You have ${context.deadlines?.filter(d => d.isOverdue).length || 0} overdue items`,
      rationale: 'Addressing overdue items helps keep the project on track',
      confidence: 'high',
      actionable: true,
    },
    {
      title: 'Check in with collaborators',
      description: `${context.collaboration?.totalCollaborators || 0} users are active`,
      rationale: 'Regular check-ins improve coordination',
      confidence: 'medium',
      actionable: true,
    },
  ];

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'suggest_next_steps',
    responseType: 'suggestion',
    contextScope: context.scope,
    entitiesIncluded: {
      overdueCount: context.deadlines?.filter(d => d.isOverdue).length || 0,
    },
  });

  return {
    responseType: 'suggestion',
    data: suggestions[0],
    metadata: {
      intent: 'suggest_next_steps',
      contextScope: context.scope,
      generatedAt: new Date().toISOString(),
    },
  };
}

export async function critiquePlan(
  userId: string,
  projectId: string,
  trackId?: string
): Promise<AIResponse> {
  const context = trackId
    ? await buildContextForTrack(trackId, userId)
    : await buildContextForProject(projectId, userId);

  const critique: AICritique = {
    subject: trackId ? `Track: ${context.tracks?.[0]?.name}` : `Project: ${context.project?.name}`,
    strengths: [
      'Items are organized into tracks',
      'Deadlines are set for planning',
    ],
    weaknesses: [
      'This is a stub - real AI would analyze dependencies, resource allocation, timeline feasibility',
    ],
    recommendations: [
      'Review and adjust deadlines based on actual progress',
      'Consider breaking down large items',
    ],
    overallAssessment: 'Stub implementation. Real AI would provide detailed critique based on project patterns.',
  };

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'critique_plan',
    responseType: 'critique',
    contextScope: context.scope,
    entitiesIncluded: { trackId: trackId || null },
  });

  return {
    responseType: 'critique',
    data: critique,
    metadata: {
      intent: 'critique_plan',
      contextScope: context.scope,
      generatedAt: new Date().toISOString(),
    },
  };
}

export async function generateChecklist(
  userId: string,
  projectId: string,
  roadmapItemId: string
): Promise<{
  success: boolean;
  draftId?: string;
  content?: DraftChecklistContent;
  error?: string;
}> {
  const context = await buildContextForRoadmapItem(roadmapItemId, userId);

  const item = context.roadmapItems?.[0];

  const draftContent: DraftChecklistContent = {
    items: [
      { text: 'Review requirements', completed: false, priority: 'high' },
      { text: 'Set up environment', completed: false, priority: 'medium' },
      { text: 'Execute work', completed: false, priority: 'high' },
      { text: 'Test results', completed: false, priority: 'medium' },
      { text: 'Document outcomes', completed: false, priority: 'low' },
    ],
    context: `Checklist for: ${item?.title}`,
  };

  const provenance: AIProvenanceMetadata = {
    sourceEntityIds: [roadmapItemId],
    sourceEntityTypes: ['roadmap_item'],
    contextSnapshot: { itemTitle: item?.title },
    generatedAt: new Date().toISOString(),
    confidenceLevel: 'medium',
  };

  const result = await createDraft({
    userId,
    projectId,
    draftType: 'checklist',
    title: `Checklist: ${item?.title || 'Item'}`,
    content: draftContent,
    provenanceMetadata: provenance,
    contextScope: context.scope,
  });

  if (!result.success || !result.draft) {
    return { success: false, error: result.error };
  }

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'generate_checklist',
    responseType: 'draft',
    contextScope: context.scope,
    entitiesIncluded: { roadmapItemId },
    draftId: result.draft.id,
  });

  return {
    success: true,
    draftId: result.draft.id,
    content: draftContent,
  };
}

export async function proposeTimeline(
  userId: string,
  projectId: string,
  trackId: string
): Promise<{
  success: boolean;
  draftId?: string;
  content?: DraftTimelineContent;
  error?: string;
}> {
  const context = await buildContextForTrack(trackId, userId);

  const track = context.tracks?.[0];

  const draftContent: DraftTimelineContent = {
    phases: [
      {
        title: 'Planning Phase',
        description: 'Define requirements and scope',
        duration: 5,
      },
      {
        title: 'Execution Phase',
        description: 'Main work execution',
        duration: 15,
      },
      {
        title: 'Review Phase',
        description: 'Testing and refinement',
        duration: 5,
      },
    ],
    totalDuration: 25,
    reasoning: `Proposed timeline for track: ${track?.name}. Based on ${context.roadmapItems?.length || 0} existing items.`,
  };

  const provenance: AIProvenanceMetadata = {
    sourceEntityIds: [trackId, ...(context.roadmapItems?.map(i => i.id) || [])],
    sourceEntityTypes: ['track', ...Array(context.roadmapItems?.length || 0).fill('roadmap_item')],
    contextSnapshot: { trackName: track?.name, itemCount: context.roadmapItems?.length },
    generatedAt: new Date().toISOString(),
    confidenceLevel: 'low',
  };

  const result = await createDraft({
    userId,
    projectId,
    draftType: 'timeline',
    title: `Timeline: ${track?.name || 'Track'}`,
    content: draftContent,
    provenanceMetadata: provenance,
    contextScope: context.scope,
  });

  if (!result.success || !result.draft) {
    return { success: false, error: result.error };
  }

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'propose_timeline',
    responseType: 'draft',
    contextScope: context.scope,
    entitiesIncluded: { trackId },
    draftId: result.draft.id,
  });

  return {
    success: true,
    draftId: result.draft.id,
    content: draftContent,
  };
}

export async function identifyRisks(
  userId: string,
  projectId: string
): Promise<{
  success: boolean;
  draftId?: string;
  content?: DraftRiskAnalysisContent;
  error?: string;
}> {
  const context = await buildContextForProject(projectId, userId);

  const overdueCount = context.deadlines?.filter(d => d.isOverdue).length || 0;

  const draftContent: DraftRiskAnalysisContent = {
    risks: [
      {
        title: 'Overdue items',
        description: `${overdueCount} items are overdue`,
        severity: overdueCount > 5 ? 'high' : 'medium',
        likelihood: 'certain',
        mitigation: 'Review and reschedule overdue items',
      },
      {
        title: 'Collaboration gaps',
        description: 'Some tracks may have low collaboration',
        severity: 'medium',
        likelihood: 'possible',
        mitigation: 'Engage team members on critical tracks',
      },
    ],
    overallAssessment: 'Stub implementation. Real AI would analyze patterns, dependencies, and historical data.',
  };

  const provenance: AIProvenanceMetadata = {
    sourceEntityIds: [projectId],
    sourceEntityTypes: ['master_project'],
    contextSnapshot: {
      projectName: context.project?.name,
      overdueCount,
      collaboratorCount: context.collaboration?.totalCollaborators,
    },
    generatedAt: new Date().toISOString(),
    confidenceLevel: 'low',
  };

  const result = await createDraft({
    userId,
    projectId,
    draftType: 'risk_analysis',
    title: `Risk Analysis: ${context.project?.name || 'Project'}`,
    content: draftContent,
    provenanceMetadata: provenance,
    contextScope: context.scope,
  });

  if (!result.success || !result.draft) {
    return { success: false, error: result.error };
  }

  await recordAIInteraction({
    userId,
    projectId,
    intent: 'identify_risks',
    responseType: 'draft',
    contextScope: context.scope,
    entitiesIncluded: { projectId, overdueCount },
    draftId: result.draft.id,
  });

  return {
    success: true,
    draftId: result.draft.id,
    content: draftContent,
  };
}

async function recordAIInteraction(
  input: RecordAIInteractionInput
): Promise<AIInteractionAudit | null> {
  const {
    userId,
    projectId,
    intent,
    responseType,
    contextScope,
    entitiesIncluded,
    draftId,
    userPrompt,
  } = input;

  const { data, error } = await supabase
    .from('ai_interaction_audit')
    .insert({
      user_id: userId,
      project_id: projectId || null,
      intent,
      response_type: responseType,
      context_scope: contextScope,
      entities_included: entitiesIncluded,
      draft_id: draftId || null,
      user_prompt: userPrompt || null,
    })
    .select()
    .maybeSingle();

  if (error || !data) {
    console.error('Failed to record AI interaction:', error);
    return null;
  }

  return {
    id: data.id,
    userId: data.user_id,
    projectId: data.project_id,
    intent: data.intent,
    responseType: data.response_type,
    contextScope: data.context_scope,
    entitiesIncluded: data.entities_included,
    draftId: data.draft_id,
    userPrompt: data.user_prompt,
    createdAt: data.created_at,
  };
}

export async function logUserMessageToConversation(
  conversationId: string,
  userId: string,
  messageText: string
): Promise<string> {
  const message = await conversationService.createMessage(
    {
      conversation_id: conversationId,
      sender_type: 'user',
      content: createTextMessage(messageText),
    },
    userId
  );
  return message.id;
}

export async function logAIResponseToConversation(
  conversationId: string,
  userId: string,
  responseText: string,
  intent: AIIntent | null = null,
  responseType: AIResponseType | null = null,
  draftId: string | null = null,
  tokenCount: number = 0
): Promise<string> {
  const message = await conversationService.createMessage(
    {
      conversation_id: conversationId,
      sender_type: 'ai',
      content: createTextMessage(responseText),
      intent,
      response_type: responseType,
      linked_draft_id: draftId,
      token_count: tokenCount,
    },
    userId
  );
  return message.id;
}

export async function logSystemMessageToConversation(
  conversationId: string,
  userId: string,
  messageText: string
): Promise<string> {
  const message = await conversationService.createMessage(
    {
      conversation_id: conversationId,
      sender_type: 'system',
      content: createTextMessage(messageText),
    },
    userId
  );
  return message.id;
}

export async function processConversationalRequest(
  userId: string,
  projectId: string,
  conversationId: string,
  userPrompt: string,
  intent: AIIntent
): Promise<{
  success: boolean;
  userMessageId: string;
  aiMessageId?: string;
  draftId?: string;
  error?: string;
}> {
  const userMessageId = await logUserMessageToConversation(
    conversationId,
    userId,
    userPrompt
  );

  let result;
  let aiResponseText = '';
  let draftId: string | null = null;

  switch (intent) {
    case 'draft_roadmap_item':
      aiResponseText = 'I could not determine which track to use. Please specify a track.';
      break;

    case 'summarize':
      result = await summariseProject(userId, projectId);
      if (result.responseType === 'summary' && 'summary' in result.data) {
        aiResponseText = result.data.summary;
      }
      break;

    case 'analyze_deadlines':
      result = await analyseDeadlines(userId, projectId);
      if (result.responseType === 'analysis' && 'summary' in result.data) {
        aiResponseText = result.data.summary;
      }
      break;

    case 'suggest_next_steps':
      result = await suggestNextSteps(userId, projectId);
      if (result.responseType === 'suggestion' && 'description' in result.data) {
        aiResponseText = `${result.data.title}: ${result.data.description}`;
      }
      break;

    default:
      aiResponseText = 'I understand your request, but I need more context to help.';
  }

  const aiMessageId = await logAIResponseToConversation(
    conversationId,
    userId,
    aiResponseText,
    intent,
    result?.responseType || 'text',
    draftId,
    0
  );

  return {
    success: true,
    userMessageId,
    aiMessageId,
    draftId: draftId || undefined,
  };
}

export const AI_SERVICE_NOTES = {
  STUB_IMPLEMENTATION: 'These are stub implementations showing architecture. Real implementation would call LLM API.',
  NO_DIRECT_WRITES: 'AI service NEVER writes to authoritative tables (tracks, roadmap_items, etc.)',
  USER_CONFIRMATION: 'All drafts require explicit user action to apply',
  PERMISSION_SAFE: 'Context assembly respects user permissions',
  AUDIT_ALL: 'Every AI interaction is logged for explainability',
  CONVERSATION_INTEGRATION: 'AI responses can be logged to conversations for chat widget support',
};
