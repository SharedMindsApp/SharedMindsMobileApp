import { supabase } from '../supabase';
import type {
  MindMeshNodeExtended,
  MindMeshEdge,
  CreateManualNodeInput,
  CreateManualEdgeInput,
  UpdateNodeInput,
  UpdateNodePositionInput,
} from './mindMeshGraphTypes';

const NODES_TABLE = 'guardrails_nodes';
const EDGES_TABLE = 'guardrails_node_links';

function transformNodeFromDb(row: any): MindMeshNodeExtended {
  return {
    id: row.id,
    masterProjectId: row.master_project_id,
    trackId: row.track_id,
    subtrackId: row.subtrack_id,
    title: row.title || '',
    content: row.content || '',
    nodeType: row.node_type,
    label: row.label || row.title || '',
    sourceType: row.source_type,
    sourceId: row.source_id,
    autoGenerated: row.auto_generated || false,
    metadata: row.metadata || {},
    xPosition: row.x_position || 0,
    yPosition: row.y_position || 0,
    width: row.width || 200,
    height: row.height || 100,
    color: row.color || '#ffffff',
    isOffshoot: row.is_offshoot || false,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function transformEdgeFromDb(row: any): MindMeshEdge {
  return {
    id: row.id,
    fromNodeId: row.from_node_id,
    toNodeId: row.to_node_id,
    linkType: row.link_type || '',
    edgeType: row.edge_type,
    direction: row.direction || 'undirected',
    autoGenerated: row.auto_generated || false,
    label: row.label,
    weight: row.weight || 1.0,
    createdAt: row.created_at,
  };
}

function camelToSnake(str: string): string {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

function transformKeysToSnake(obj: Record<string, any>): Record<string, any> {
  const result: Record<string, any> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[camelToSnake(key)] = value;
  }
  return result;
}

export async function createManualIdeaNode(
  input: CreateManualNodeInput
): Promise<MindMeshNodeExtended | null> {
  const dbInput = {
    master_project_id: input.masterProjectId,
    label: input.label,
    title: input.label,
    content: input.content || '',
    node_type: 'idea',
    source_type: 'idea',
    auto_generated: false,
    x_position: input.xPosition || 0,
    y_position: input.yPosition || 0,
    width: input.width || 200,
    height: input.height || 100,
    color: input.color || '#f59e0b',
    metadata: input.metadata || {},
  };

  const { data, error } = await supabase
    .from(NODES_TABLE)
    .insert(dbInput)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error creating manual node:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

export async function createManualEdge(
  input: CreateManualEdgeInput
): Promise<MindMeshEdge | null> {
  const existing = await findEdgeByNodes(
    input.fromNodeId,
    input.toNodeId,
    input.edgeType
  );

  if (existing) {
    return existing;
  }

  const dbInput = {
    from_node_id: input.fromNodeId,
    to_node_id: input.toNodeId,
    edge_type: input.edgeType,
    link_type: input.edgeType,
    direction: input.direction || 'undirected',
    auto_generated: false,
    label: input.label,
    weight: input.weight || 1.0,
  };

  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .insert(dbInput)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error creating manual edge:', error);
    return null;
  }

  return data ? transformEdgeFromDb(data) : null;
}

async function findEdgeByNodes(
  fromNodeId: string,
  toNodeId: string,
  edgeType: string
): Promise<MindMeshEdge | null> {
  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('from_node_id', fromNodeId)
    .eq('to_node_id', toNodeId)
    .eq('edge_type', edgeType)
    .maybeSingle();

  if (error) {
    return null;
  }

  return data ? transformEdgeFromDb(data) : null;
}

export async function updateManualNode(
  nodeId: string,
  input: UpdateNodeInput
): Promise<MindMeshNodeExtended | null> {
  const node = await getNodeById(nodeId);
  if (!node) return null;

  if (node.autoGenerated) {
    console.error('Cannot update auto-generated node');
    return null;
  }

  const updates: Record<string, any> = {};

  if (input.label !== undefined) {
    updates.label = input.label;
    updates.title = input.label;
  }

  if (input.content !== undefined) updates.content = input.content;
  if (input.xPosition !== undefined) updates.x_position = input.xPosition;
  if (input.yPosition !== undefined) updates.y_position = input.yPosition;
  if (input.width !== undefined) updates.width = input.width;
  if (input.height !== undefined) updates.height = input.height;
  if (input.color !== undefined) updates.color = input.color;
  if (input.metadata !== undefined) updates.metadata = input.metadata;

  const { data, error } = await supabase
    .from(NODES_TABLE)
    .update(updates)
    .eq('id', nodeId)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error updating manual node:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

export async function updateNodePosition(
  input: UpdateNodePositionInput
): Promise<MindMeshNodeExtended | null> {
  const { data, error } = await supabase
    .from(NODES_TABLE)
    .update({
      x_position: input.xPosition,
      y_position: input.yPosition,
    })
    .eq('id', input.nodeId)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error updating node position:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

export async function deleteManualNode(nodeId: string): Promise<boolean> {
  const node = await getNodeById(nodeId);
  if (!node) return false;

  if (node.autoGenerated) {
    console.error('Cannot delete auto-generated node');
    return false;
  }

  const { error } = await supabase.from(NODES_TABLE).delete().eq('id', nodeId);

  if (error) {
    console.error('Error deleting manual node:', error);
    return false;
  }

  return true;
}

export async function deleteManualEdge(edgeId: string): Promise<boolean> {
  const edge = await getEdgeById(edgeId);
  if (!edge) return false;

  if (edge.autoGenerated) {
    console.error('Cannot delete auto-generated edge');
    return false;
  }

  const { error } = await supabase.from(EDGES_TABLE).delete().eq('id', edgeId);

  if (error) {
    console.error('Error deleting manual edge:', error);
    return false;
  }

  return true;
}

export async function getNodeById(nodeId: string): Promise<MindMeshNodeExtended | null> {
  const { data, error } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('id', nodeId)
    .maybeSingle();

  if (error) {
    console.error('Error fetching node:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

export async function getEdgeById(edgeId: string): Promise<MindMeshEdge | null> {
  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('id', edgeId)
    .maybeSingle();

  if (error) {
    console.error('Error fetching edge:', error);
    return null;
  }

  return data ? transformEdgeFromDb(data) : null;
}

export async function getManualNodes(
  masterProjectId: string
): Promise<MindMeshNodeExtended[]> {
  const { data, error } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId)
    .eq('auto_generated', false);

  if (error) {
    console.error('Error fetching manual nodes:', error);
    return [];
  }

  return (data || []).map(transformNodeFromDb);
}

export async function getManualEdges(
  masterProjectId: string
): Promise<MindMeshEdge[]> {
  const { data: nodesData } = await supabase
    .from(NODES_TABLE)
    .select('id')
    .eq('master_project_id', masterProjectId);

  if (!nodesData || nodesData.length === 0) return [];

  const nodeIds = nodesData.map((n) => n.id);

  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .in('from_node_id', nodeIds)
    .eq('auto_generated', false);

  if (error) {
    console.error('Error fetching manual edges:', error);
    return [];
  }

  return (data || []).map(transformEdgeFromDb);
}

export async function bulkCreateManualNodes(
  inputs: CreateManualNodeInput[]
): Promise<MindMeshNodeExtended[]> {
  const dbInputs = inputs.map((input) => ({
    master_project_id: input.masterProjectId,
    label: input.label,
    title: input.label,
    content: input.content || '',
    node_type: 'idea',
    source_type: 'idea',
    auto_generated: false,
    x_position: input.xPosition || 0,
    y_position: input.yPosition || 0,
    width: input.width || 200,
    height: input.height || 100,
    color: input.color || '#f59e0b',
    metadata: input.metadata || {},
  }));

  const { data, error } = await supabase
    .from(NODES_TABLE)
    .insert(dbInputs)
    .select();

  if (error) {
    console.error('Error bulk creating manual nodes:', error);
    return [];
  }

  return (data || []).map(transformNodeFromDb);
}

export async function bulkUpdateNodePositions(
  updates: UpdateNodePositionInput[]
): Promise<void> {
  for (const update of updates) {
    await updateNodePosition(update);
  }
}

export async function duplicateManualNode(
  nodeId: string,
  xOffset: number = 50,
  yOffset: number = 50
): Promise<MindMeshNodeExtended | null> {
  const original = await getNodeById(nodeId);
  if (!original || original.autoGenerated) return null;

  const input: CreateManualNodeInput = {
    masterProjectId: original.masterProjectId,
    label: `${original.label} (copy)`,
    content: original.content,
    xPosition: original.xPosition + xOffset,
    yPosition: original.yPosition + yOffset,
    width: original.width,
    height: original.height,
    color: original.color,
    metadata: original.metadata,
  };

  return createManualIdeaNode(input);
}
