import { supabase } from '../supabase';
import type {
  MindMeshNodeExtended,
  MindMeshEdge,
  MindMeshGraphData,
  NodeNeighbors,
  GraphStatistics,
  GraphQuery,
  NodeSearchResult,
  GraphValidationResult,
  FocusContext,
  MindMeshSourceType,
  MindMeshEdgeType,
} from './mindMeshGraphTypes';
import {
  getAutoGeneratedNodes,
  getAutoGeneratedEdges,
} from './mindMeshAutoGenService';
import { getManualNodes, getManualEdges } from './mindMeshManualService';
import {
  getAllVisibilityPreferences,
  getHiddenNodes,
  getHiddenEdges,
  filterVisibleNodes,
  filterVisibleEdges,
} from './mindMeshVisibilityService';

const NODES_TABLE = 'guardrails_nodes';
const EDGES_TABLE = 'guardrails_node_links';

function transformNodeFromDb(row: any): MindMeshNodeExtended {
  return {
    id: row.id,
    masterProjectId: row.master_project_id,
    trackId: row.track_id,
    subtrackId: row.subtrack_id,
    title: row.title || '',
    content: row.content || '',
    nodeType: row.node_type,
    label: row.label || row.title || '',
    sourceType: row.source_type,
    sourceId: row.source_id,
    autoGenerated: row.auto_generated || false,
    metadata: row.metadata || {},
    xPosition: row.x_position || 0,
    yPosition: row.y_position || 0,
    width: row.width || 200,
    height: row.height || 100,
    color: row.color || '#ffffff',
    isOffshoot: row.is_offshoot || false,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function transformEdgeFromDb(row: any): MindMeshEdge {
  return {
    id: row.id,
    fromNodeId: row.from_node_id,
    toNodeId: row.to_node_id,
    linkType: row.link_type || '',
    edgeType: row.edge_type,
    direction: row.direction || 'undirected',
    autoGenerated: row.auto_generated || false,
    label: row.label,
    weight: row.weight || 1.0,
    createdAt: row.created_at,
  };
}

export async function getFullGraph(
  masterProjectId: string,
  userId?: string
): Promise<MindMeshGraphData> {
  const { data: nodesData } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId);

  const nodes = (nodesData || []).map(transformNodeFromDb);

  if (nodes.length === 0) {
    return {
      nodes: [],
      edges: [],
      visibilityPreferences: [],
    };
  }

  const nodeIds = nodes.map((n) => n.id);

  const { data: edgesData } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .in('from_node_id', nodeIds);

  const edges = (edgesData || []).map(transformEdgeFromDb);

  const visibilityPreferences = userId
    ? await getAllVisibilityPreferences(userId, masterProjectId)
    : [];

  return {
    nodes,
    edges,
    visibilityPreferences,
  };
}

export async function getFilteredGraph(
  query: GraphQuery
): Promise<MindMeshGraphData> {
  let nodesQuery = supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', query.masterProjectId);

  if (query.includeAutoGenerated === false) {
    nodesQuery = nodesQuery.eq('auto_generated', false);
  } else if (query.includeManual === false) {
    nodesQuery = nodesQuery.eq('auto_generated', true);
  }

  if (query.sourceTypes && query.sourceTypes.length > 0) {
    nodesQuery = nodesQuery.in('source_type', query.sourceTypes);
  }

  const { data: nodesData } = await nodesQuery;
  let nodes = (nodesData || []).map(transformNodeFromDb);

  if (nodes.length === 0) {
    return {
      nodes: [],
      edges: [],
      visibilityPreferences: [],
    };
  }

  const nodeIds = nodes.map((n) => n.id);

  let edgesQuery = supabase
    .from(EDGES_TABLE)
    .select('*')
    .in('from_node_id', nodeIds);

  if (query.edgeTypes && query.edgeTypes.length > 0) {
    edgesQuery = edgesQuery.in('edge_type', query.edgeTypes);
  }

  const { data: edgesData } = await edgesQuery;
  let edges = (edgesData || []).map(transformEdgeFromDb);

  let visibilityPreferences = [];

  if (query.respectVisibility && query.userId) {
    visibilityPreferences = await getAllVisibilityPreferences(
      query.userId,
      query.masterProjectId
    );

    const hiddenNodeIds = await getHiddenNodes(query.userId, query.masterProjectId);
    const hiddenEdgeIds = await getHiddenEdges(query.userId, query.masterProjectId);

    nodes = filterVisibleNodes(nodes, hiddenNodeIds, []);
    edges = filterVisibleEdges(edges, hiddenEdgeIds, hiddenNodeIds);
  }

  return {
    nodes,
    edges,
    visibilityPreferences,
  };
}

export async function getNodeNeighbors(nodeId: string): Promise<NodeNeighbors | null> {
  const { data: nodeData } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('id', nodeId)
    .maybeSingle();

  if (!nodeData) return null;

  const node = transformNodeFromDb(nodeData);

  const { data: outgoingEdgesData } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('from_node_id', nodeId);

  const outgoingEdges = (outgoingEdgesData || []).map(transformEdgeFromDb);

  const { data: incomingEdgesData } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('to_node_id', nodeId);

  const incomingEdges = (incomingEdgesData || []).map(transformEdgeFromDb);

  const outgoingNodeIds = outgoingEdges.map((e) => e.toNodeId);
  const incomingNodeIds = incomingEdges.map((e) => e.fromNodeId);

  let outgoingNodes: MindMeshNodeExtended[] = [];
  let incomingNodes: MindMeshNodeExtended[] = [];

  if (outgoingNodeIds.length > 0) {
    const { data } = await supabase
      .from(NODES_TABLE)
      .select('*')
      .in('id', outgoingNodeIds);
    outgoingNodes = (data || []).map(transformNodeFromDb);
  }

  if (incomingNodeIds.length > 0) {
    const { data } = await supabase
      .from(NODES_TABLE)
      .select('*')
      .in('id', incomingNodeIds);
    incomingNodes = (data || []).map(transformNodeFromDb);
  }

  return {
    node,
    incomingEdges,
    outgoingEdges,
    incomingNodes,
    outgoingNodes,
  };
}

export async function getFocusedSubgraph(
  context: FocusContext
): Promise<MindMeshGraphData> {
  const visited = new Set<string>();
  const nodesToProcess: Array<{ id: string; depth: number }> = [
    { id: context.centerNodeId, depth: 0 },
  ];
  const resultNodes: MindMeshNodeExtended[] = [];
  const resultEdges: MindMeshEdge[] = [];

  while (nodesToProcess.length > 0) {
    const current = nodesToProcess.shift()!;

    if (visited.has(current.id) || current.depth > context.depth) {
      continue;
    }

    visited.add(current.id);

    const neighbors = await getNodeNeighbors(current.id);
    if (!neighbors) continue;

    const shouldInclude =
      (context.includeAutoGenerated && neighbors.node.autoGenerated) ||
      (context.includeManual && !neighbors.node.autoGenerated);

    if (shouldInclude) {
      resultNodes.push(neighbors.node);

      resultEdges.push(...neighbors.incomingEdges);
      resultEdges.push(...neighbors.outgoingEdges);

      if (current.depth < context.depth) {
        for (const inNode of neighbors.incomingNodes) {
          nodesToProcess.push({ id: inNode.id, depth: current.depth + 1 });
        }
        for (const outNode of neighbors.outgoingNodes) {
          nodesToProcess.push({ id: outNode.id, depth: current.depth + 1 });
        }
      }
    }
  }

  const uniqueEdges = Array.from(
    new Map(resultEdges.map((e) => [e.id, e])).values()
  );

  return {
    nodes: resultNodes,
    edges: uniqueEdges,
    visibilityPreferences: [],
  };
}

export async function searchNodes(
  masterProjectId: string,
  searchTerm: string
): Promise<NodeSearchResult[]> {
  const searchLower = searchTerm.toLowerCase();

  const { data } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId);

  const nodes = (data || []).map(transformNodeFromDb);

  const results: NodeSearchResult[] = [];

  for (const node of nodes) {
    let score = 0;
    let matchType: 'label' | 'content' | 'metadata' = 'label';

    if (node.label.toLowerCase().includes(searchLower)) {
      score = 100;
      matchType = 'label';
    } else if (node.content.toLowerCase().includes(searchLower)) {
      score = 50;
      matchType = 'content';
    } else if (JSON.stringify(node.metadata).toLowerCase().includes(searchLower)) {
      score = 25;
      matchType = 'metadata';
    }

    if (score > 0) {
      results.push({ node, score, matchType });
    }
  }

  return results.sort((a, b) => b.score - a.score);
}

export async function getGraphStatistics(
  masterProjectId: string
): Promise<GraphStatistics> {
  const graph = await getFullGraph(masterProjectId);

  const stats: GraphStatistics = {
    totalNodes: graph.nodes.length,
    autoGeneratedNodes: graph.nodes.filter((n) => n.autoGenerated).length,
    manualNodes: graph.nodes.filter((n) => !n.autoGenerated).length,
    nodesBySourceType: {
      track: 0,
      roadmap_item: 0,
      person: 0,
      document: 0,
      idea: 0,
    },
    totalEdges: graph.edges.length,
    autoGeneratedEdges: graph.edges.filter((e) => e.autoGenerated).length,
    manualEdges: graph.edges.filter((e) => !e.autoGenerated).length,
    edgesByType: {
      hierarchy: 0,
      reference: 0,
      composition: 0,
      ideation: 0,
      influence: 0,
      derivation: 0,
      dependency: 0,
      supporting: 0,
      offshoot: 0,
    },
    hiddenNodesCount: 0,
    hiddenEdgesCount: 0,
  };

  for (const node of graph.nodes) {
    if (node.sourceType) {
      stats.nodesBySourceType[node.sourceType]++;
    }
  }

  for (const edge of graph.edges) {
    if (edge.edgeType) {
      stats.edgesByType[edge.edgeType]++;
    }
  }

  return stats;
}

export async function validateGraph(
  masterProjectId: string
): Promise<GraphValidationResult> {
  const graph = await getFullGraph(masterProjectId);

  const result: GraphValidationResult = {
    isValid: true,
    orphanedNodes: [],
    invalidEdges: [],
    missingSourceReferences: [],
  };

  const nodeIdSet = new Set(graph.nodes.map((n) => n.id));

  for (const edge of graph.edges) {
    if (!nodeIdSet.has(edge.fromNodeId) || !nodeIdSet.has(edge.toNodeId)) {
      result.invalidEdges.push(edge);
      result.isValid = false;
    }
  }

  const connectedNodeIds = new Set<string>();
  for (const edge of graph.edges) {
    connectedNodeIds.add(edge.fromNodeId);
    connectedNodeIds.add(edge.toNodeId);
  }

  for (const node of graph.nodes) {
    if (!connectedNodeIds.has(node.id) && node.autoGenerated) {
      result.orphanedNodes.push(node);
    }
  }

  for (const node of graph.nodes) {
    if (node.sourceId && node.sourceType) {
      if (node.sourceType === 'track') {
        const { data } = await supabase
          .from('guardrails_tracks')
          .select('id')
          .eq('id', node.sourceId)
          .maybeSingle();

        if (!data) {
          result.missingSourceReferences.push(node);
          result.isValid = false;
        }
      } else if (node.sourceType === 'roadmap_item') {
        const { data } = await supabase
          .from('guardrails_roadmap_items')
          .select('id')
          .eq('id', node.sourceId)
          .maybeSingle();

        if (!data) {
          result.missingSourceReferences.push(node);
          result.isValid = false;
        }
      }
    }
  }

  return result;
}

export async function getNodesBySourceType(
  masterProjectId: string,
  sourceType: MindMeshSourceType
): Promise<MindMeshNodeExtended[]> {
  const { data } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId)
    .eq('source_type', sourceType);

  return (data || []).map(transformNodeFromDb);
}

export async function getEdgesByType(
  masterProjectId: string,
  edgeType: MindMeshEdgeType
): Promise<MindMeshEdge[]> {
  const { data: nodesData } = await supabase
    .from(NODES_TABLE)
    .select('id')
    .eq('master_project_id', masterProjectId);

  if (!nodesData || nodesData.length === 0) return [];

  const nodeIds = nodesData.map((n) => n.id);

  const { data } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .in('from_node_id', nodeIds)
    .eq('edge_type', edgeType);

  return (data || []).map(transformEdgeFromDb);
}

export async function getEdgesBetweenNodes(
  fromNodeId: string,
  toNodeId: string
): Promise<MindMeshEdge[]> {
  const { data } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('from_node_id', fromNodeId)
    .eq('to_node_id', toNodeId);

  return (data || []).map(transformEdgeFromDb);
}

export function groupNodesBySourceType(
  nodes: MindMeshNodeExtended[]
): Record<MindMeshSourceType, MindMeshNodeExtended[]> {
  const grouped: Record<MindMeshSourceType, MindMeshNodeExtended[]> = {
    track: [],
    roadmap_item: [],
    person: [],
    document: [],
    idea: [],
  };

  for (const node of nodes) {
    if (node.sourceType) {
      grouped[node.sourceType].push(node);
    }
  }

  return grouped;
}

export function groupEdgesByType(
  edges: MindMeshEdge[]
): Record<MindMeshEdgeType, MindMeshEdge[]> {
  const grouped: Record<MindMeshEdgeType, MindMeshEdge[]> = {
    hierarchy: [],
    reference: [],
    composition: [],
    ideation: [],
    influence: [],
    derivation: [],
    dependency: [],
    supporting: [],
    offshoot: [],
  };

  for (const edge of edges) {
    if (edge.edgeType) {
      grouped[edge.edgeType].push(edge);
    }
  }

  return grouped;
}
