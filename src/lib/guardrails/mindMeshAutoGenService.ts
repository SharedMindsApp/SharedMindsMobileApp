import { supabase } from '../supabase';
import type {
  MindMeshNodeExtended,
  MindMeshEdge,
  MindMeshSourceType,
  MindMeshEdgeType,
  CreateAutoNodeInput,
  CreateAutoEdgeInput,
  AutoGenerationResult,
  AutoGenerationRules,
} from './mindMeshGraphTypes';
import type { Track } from './tracksTypes';
import type { RoadmapItem } from './coreTypes';

const NODES_TABLE = 'guardrails_nodes';
const EDGES_TABLE = 'guardrails_node_links';

function transformNodeFromDb(row: any): MindMeshNodeExtended {
  return {
    id: row.id,
    masterProjectId: row.master_project_id,
    trackId: row.track_id,
    subtrackId: row.subtrack_id,
    title: row.title || '',
    content: row.content || '',
    nodeType: row.node_type,
    label: row.label || row.title || '',
    sourceType: row.source_type,
    sourceId: row.source_id,
    autoGenerated: row.auto_generated || false,
    metadata: row.metadata || {},
    xPosition: row.x_position || 0,
    yPosition: row.y_position || 0,
    width: row.width || 200,
    height: row.height || 100,
    color: row.color || '#ffffff',
    isOffshoot: row.is_offshoot || false,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

function transformEdgeFromDb(row: any): MindMeshEdge {
  return {
    id: row.id,
    fromNodeId: row.from_node_id,
    toNodeId: row.to_node_id,
    linkType: row.link_type || '',
    edgeType: row.edge_type,
    direction: row.direction || 'undirected',
    autoGenerated: row.auto_generated || false,
    label: row.label,
    weight: row.weight || 1.0,
    createdAt: row.created_at,
  };
}

function camelToSnake(str: string): string {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

function transformKeysToSnake(obj: Record<string, any>): Record<string, any> {
  const result: Record<string, any> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[camelToSnake(key)] = value;
  }
  return result;
}

export async function createAutoNode(input: CreateAutoNodeInput): Promise<MindMeshNodeExtended | null> {
  const existing = await findNodeBySource(
    input.masterProjectId,
    input.sourceType,
    input.sourceId
  );

  if (existing) {
    return existing;
  }

  const dbInput = {
    master_project_id: input.masterProjectId,
    source_type: input.sourceType,
    source_id: input.sourceId,
    label: input.label,
    title: input.label,
    node_type: 'idea',
    metadata: input.metadata || {},
    auto_generated: true,
    x_position: input.xPosition || 0,
    y_position: input.yPosition || 0,
    color: input.color || determineColorBySourceType(input.sourceType),
  };

  const { data, error } = await supabase
    .from(NODES_TABLE)
    .insert(dbInput)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error creating auto node:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

export async function createAutoEdge(input: CreateAutoEdgeInput): Promise<MindMeshEdge | null> {
  const existing = await findEdgeByNodes(
    input.fromNodeId,
    input.toNodeId,
    input.edgeType
  );

  if (existing) {
    return existing;
  }

  const dbInput = {
    from_node_id: input.fromNodeId,
    to_node_id: input.toNodeId,
    edge_type: input.edgeType,
    link_type: input.edgeType,
    direction: input.direction || 'undirected',
    auto_generated: true,
    label: input.label,
  };

  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .insert(dbInput)
    .select()
    .maybeSingle();

  if (error) {
    console.error('Error creating auto edge:', error);
    return null;
  }

  return data ? transformEdgeFromDb(data) : null;
}

export async function findNodeBySource(
  masterProjectId: string,
  sourceType: MindMeshSourceType,
  sourceId: string
): Promise<MindMeshNodeExtended | null> {
  const { data, error } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId)
    .eq('source_type', sourceType)
    .eq('source_id', sourceId)
    .maybeSingle();

  if (error) {
    console.error('Error finding node by source:', error);
    return null;
  }

  return data ? transformNodeFromDb(data) : null;
}

async function findEdgeByNodes(
  fromNodeId: string,
  toNodeId: string,
  edgeType: MindMeshEdgeType
): Promise<MindMeshEdge | null> {
  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .eq('from_node_id', fromNodeId)
    .eq('to_node_id', toNodeId)
    .eq('edge_type', edgeType)
    .maybeSingle();

  if (error) {
    return null;
  }

  return data ? transformEdgeFromDb(data) : null;
}

export async function generateGraphFromTracks(
  masterProjectId: string,
  tracks: Track[]
): Promise<AutoGenerationResult> {
  const result: AutoGenerationResult = {
    nodesCreated: 0,
    edgesCreated: 0,
    nodesUpdated: 0,
    errors: [],
  };

  const nodeMap = new Map<string, MindMeshNodeExtended>();

  for (const track of tracks) {
    try {
      const node = await createAutoNode({
        masterProjectId,
        sourceType: 'track',
        sourceId: track.id,
        label: track.name,
        metadata: {
          color: track.color,
          status: track.status,
          parentTrackId: track.parentTrackId,
        },
        color: track.color || '#3b82f6',
      });

      if (node) {
        nodeMap.set(track.id, node);
        result.nodesCreated++;
      }
    } catch (error) {
      result.errors.push(`Failed to create node for track ${track.id}: ${error}`);
    }
  }

  for (const track of tracks) {
    if (track.parentTrackId) {
      const childNode = nodeMap.get(track.id);
      const parentNode = nodeMap.get(track.parentTrackId);

      if (childNode && parentNode) {
        try {
          const edge = await createAutoEdge({
            fromNodeId: parentNode.id,
            toNodeId: childNode.id,
            edgeType: 'hierarchy',
            direction: 'directed',
            label: 'subtrack',
          });

          if (edge) {
            result.edgesCreated++;
          }
        } catch (error) {
          result.errors.push(
            `Failed to create hierarchy edge: ${track.parentTrackId} → ${track.id}`
          );
        }
      }
    }
  }

  return result;
}

export async function generateGraphFromRoadmapItems(
  masterProjectId: string,
  roadmapItems: RoadmapItem[]
): Promise<AutoGenerationResult> {
  const result: AutoGenerationResult = {
    nodesCreated: 0,
    edgesCreated: 0,
    nodesUpdated: 0,
    errors: [],
  };

  const nodeMap = new Map<string, MindMeshNodeExtended>();

  for (const item of roadmapItems) {
    try {
      const node = await createAutoNode({
        masterProjectId,
        sourceType: 'roadmap_item',
        sourceId: item.id,
        label: item.title,
        metadata: {
          type: item.type,
          status: item.status,
          trackId: item.trackId,
          startDate: item.startDate,
          endDate: item.endDate,
          parentItemId: item.parentItemId,
          itemDepth: item.itemDepth,
        },
        color: determineColorByItemType(item.type),
      });

      if (node) {
        nodeMap.set(item.id, node);
        result.nodesCreated++;

        if (item.trackId) {
          const trackNode = await findNodeBySource(
            masterProjectId,
            'track',
            item.trackId
          );

          if (trackNode) {
            const edge = await createAutoEdge({
              fromNodeId: trackNode.id,
              toNodeId: node.id,
              edgeType: 'reference',
              direction: 'undirected',
              label: 'contains',
            });

            if (edge) {
              result.edgesCreated++;
            }
          }
        }
      }
    } catch (error) {
      result.errors.push(`Failed to create node for roadmap item ${item.id}: ${error}`);
    }
  }

  for (const item of roadmapItems) {
    if (item.parentItemId) {
      const childNode = nodeMap.get(item.id);
      const parentNode = nodeMap.get(item.parentItemId);

      if (childNode && parentNode) {
        try {
          const edge = await createAutoEdge({
            fromNodeId: parentNode.id,
            toNodeId: childNode.id,
            edgeType: 'composition',
            direction: 'directed',
            label: 'contains',
          });

          if (edge) {
            result.edgesCreated++;
          }
        } catch (error) {
          result.errors.push(
            `Failed to create composition edge: ${item.parentItemId} → ${item.id}`
          );
        }
      }
    }
  }

  return result;
}

export async function autoGenerateFullGraph(
  masterProjectId: string,
  rules: AutoGenerationRules = {
    generateTrackHierarchy: true,
    generateRoadmapItemNodes: true,
    generatePeopleNodes: false,
    generateTrackToItemEdges: true,
    generateItemToPeopleEdges: false,
  }
): Promise<AutoGenerationResult> {
  const totalResult: AutoGenerationResult = {
    nodesCreated: 0,
    edgesCreated: 0,
    nodesUpdated: 0,
    errors: [],
  };

  try {
    if (rules.generateTrackHierarchy) {
      const { data: tracksData } = await supabase
        .from('guardrails_tracks')
        .select('*')
        .eq('master_project_id', masterProjectId);

      if (tracksData) {
        const tracksResult = await generateGraphFromTracks(
          masterProjectId,
          tracksData as any
        );
        totalResult.nodesCreated += tracksResult.nodesCreated;
        totalResult.edgesCreated += tracksResult.edgesCreated;
        totalResult.errors.push(...tracksResult.errors);
      }
    }

    if (rules.generateRoadmapItemNodes) {
      const { data: itemsData } = await supabase
        .from('guardrails_roadmap_items')
        .select('*')
        .eq('master_project_id', masterProjectId);

      if (itemsData) {
        const itemsResult = await generateGraphFromRoadmapItems(
          masterProjectId,
          itemsData as any
        );
        totalResult.nodesCreated += itemsResult.nodesCreated;
        totalResult.edgesCreated += itemsResult.edgesCreated;
        totalResult.errors.push(...itemsResult.errors);
      }
    }
  } catch (error) {
    totalResult.errors.push(`Auto-generation failed: ${error}`);
  }

  return totalResult;
}

export async function syncAutoGeneratedNodes(
  masterProjectId: string
): Promise<AutoGenerationResult> {
  return autoGenerateFullGraph(masterProjectId);
}

export async function deleteAutoGeneratedNodesForProject(
  masterProjectId: string
): Promise<void> {
  await supabase
    .from(NODES_TABLE)
    .delete()
    .eq('master_project_id', masterProjectId)
    .eq('auto_generated', true);
}

export async function getAutoGeneratedNodes(
  masterProjectId: string
): Promise<MindMeshNodeExtended[]> {
  const { data, error } = await supabase
    .from(NODES_TABLE)
    .select('*')
    .eq('master_project_id', masterProjectId)
    .eq('auto_generated', true);

  if (error) {
    console.error('Error fetching auto-generated nodes:', error);
    return [];
  }

  return (data || []).map(transformNodeFromDb);
}

export async function getAutoGeneratedEdges(
  masterProjectId: string
): Promise<MindMeshEdge[]> {
  const { data: nodesData } = await supabase
    .from(NODES_TABLE)
    .select('id')
    .eq('master_project_id', masterProjectId);

  if (!nodesData || nodesData.length === 0) return [];

  const nodeIds = nodesData.map((n) => n.id);

  const { data, error } = await supabase
    .from(EDGES_TABLE)
    .select('*')
    .in('from_node_id', nodeIds)
    .eq('auto_generated', true);

  if (error) {
    console.error('Error fetching auto-generated edges:', error);
    return [];
  }

  return (data || []).map(transformEdgeFromDb);
}

function determineColorBySourceType(sourceType: MindMeshSourceType): string {
  switch (sourceType) {
    case 'track':
      return '#3b82f6';
    case 'roadmap_item':
      return '#8b5cf6';
    case 'person':
      return '#ec4899';
    case 'document':
      return '#10b981';
    case 'idea':
      return '#f59e0b';
    default:
      return '#6b7280';
  }
}

function determineColorByItemType(itemType: string): string {
  switch (itemType) {
    case 'task':
      return '#06b6d4';
    case 'milestone':
      return '#f59e0b';
    case 'event':
      return '#8b5cf6';
    case 'goal':
      return '#ec4899';
    case 'habit':
      return '#10b981';
    default:
      return '#6b7280';
  }
}
